{
  "results": [
    {
      "input": "معايير أداء وسرعة المواقع: Core Web Vitals (LCP, FID, CLS, INP), Google Lighthouse, Page Speed Optimization, Lazy Loading, Code Splitting, Tree Shaking, Bundle Optimization, Critical CSS, Preloading, Prefetching",
      "output": {
        "topic_title": "معايير أداء وسرعة المواقع: Core Web Vitals وكل ما تريد معرفته",
        "introduction": "تعتبر سرعة وأداء المواقع الإلكترونية من أهم العوامل التي تحدد نجاحها في العصر الرقمي الحالي. فالمستخدمون يتوقعون تجربة تصفح سريعة وسلسة، وأي تأخير أو عدم استقرار في عرض المحتوى قد يؤدي إلى إحباطهم ومغادرتهم للموقع فوراً. وإدراكاً لهذه الأهمية، قدمت جوجل مجموعة من المقاييس والمعايير تحت مسمى \"Core Web Vitals\" لتقييم تجربة المستخدم بشكل موضوعي. تركز هذه المعايير على ثلاثة جوانب أساسية: سرعة التحميل (LCP)، وسرعة الاستجابة للتفاعل (INP)، والاستقرار البصري (CLS). إن فهم هذه المعايير وتطبيق أفضل الممارسات لتحسينها لم يعد خياراً، بل ضرورة حتمية لضمان ظهور الموقع في مراتب متقدمة في نتائج البحث وتقديم تجربة مستخدم استثنائية.",
        "key_concepts": "### مؤشرات أداء الويب الأساسية (Core Web Vitals)\nهي مجموعة من المقاييس المحددة من جوجل والتي تعتبرها حاسمة لتجربة المستخدم على الويب. تشمل هذه المقاييس:\n\n*   **Largest Contentful Paint (LCP):** يقيس سرعة تحميل أكبر عنصر مرئي (صورة أو كتلة نصية) في الصفحة. للحصول على تجربة مستخدم جيدة، يجب أن يتم تحميل هذا العنصر في غضون 2.5 ثانية من بدء تحميل الصفحة.\n*   **Interaction to Next Paint (INP):** يقيس مدى سرعة استجابة الصفحة لتفاعلات المستخدم (مثل النقر على زر أو إدخال نص). تجربة المستخدم الجيدة تتطلب أن يكون زمن الاستجابة أقل من 200 مللي ثانية.\n*   **Cumulative Layout Shift (CLS):** يقيس مدى الاستقرار البصري للصفحة، أي هل تحدث تغييرات غير متوقعة في تخطيط الصفحة أثناء تحميلها. يجب أن يكون معدل CLS أقل من 0.1 لتجربة جيدة.\n*   **First Input Delay (FID):** (مقياس سابق تم استبداله بـ INP) كان يقيس الوقت المستغرق من أول تفاعل للمستخدم مع الصفحة حتى يتمكن المتصفح من معالجة هذا التفاعل.\n\n### أدوات وتقنيات تحسين الأداء\n\n*   **Google Lighthouse:** أداة مفتوحة المصدر ومؤتمتة من جوجل لتحسين جودة صفحات الويب. تقوم بتقييم الأداء، وإمكانية الوصول، وأفضل الممارسات، وتحسين محركات البحث (SEO).\n*   **Page Speed Optimization:** مجموعة من التقنيات والممارسات التي تهدف إلى تقليل الوقت الذي تستغرقه الصفحة للتحميل والعرض بشكل كامل في متصفح المستخدم.\n*   **Lazy Loading (التحميل الكسول):** تقنية تؤخر تحميل الموارد غير الضرورية (مثل الصور أو الفيديوهات الموجودة خارج إطار العرض الأولي) إلى أن يحتاجها المستخدم بالفعل (عندما يقوم بالتمرير إليها). هذا يسرع من التحميل الأولي للصفحة.\n*   **Code Splitting (تقسيم الكود):** عملية تقسيم حزمة الكود الكبيرة (Bundle) إلى أجزاء أصغر يمكن تحميلها عند الحاجة. هذا يقلل من حجم الكود الأولي الذي يجب على المتصفح تحميله وتحليله.\n*   **Tree Shaking:** عملية إزالة الكود غير المستخدم (Dead Code) من حزم JavaScript. تعمل هذه التقنية عن طريق تحليل الاعتماديات (dependencies) في الكود وإزالة أي شيء لم يتم استيراده أو استخدامه.\n*   **Bundle Optimization (تحسين الحزمة):** يشمل مجموعة من التقنيات مثل التصغير (Minification)، والضغط (Compression)، وتقسيم الكود، و Tree Shaking لتقليل الحجم الإجمالي لحزم الكود (JavaScript, CSS).\n*   **Critical CSS (CSS الحرج):** تقنية استخراج الأنماط (CSS) اللازمة لعرض الجزء العلوي من الصفحة (Above the Fold) وتضمينها مباشرة في ملف HTML. هذا يسمح للمتصفح بعرض المحتوى الأساسي بسرعة دون انتظار تحميل ملفات CSS الكاملة.\n*   **Preloading (التحميل المسبق):** تقنية تلميح للمتصفح بأن موردًا معينًا (مثل خط أو صورة) سيكون مطلوبًا قريبًا، مما يدفعه إلى بدء تحميله في وقت مبكر وبأولوية أعلى.\n*   **Prefetching (الجلب المسبق):** تقنية تلميح للمتصفح بأن موردًا معينًا قد يكون مطلوبًا في التنقلات المستقبلية (صفحات أخرى)، مما يدفعه إلى جلبه وتخزينه في ذاكرة التخزين المؤقت عندما يكون المتصفح خاملاً.",
        "best_practices": "### أفضل الممارسات لتحسين مؤشرات أداء الويب الأساسية (Core Web Vitals)\n\n#### 1. تحسين Largest Contentful Paint (LCP)\n\n*   **اجعل المورد الأساسي قابلاً للاكتشاف من المصدر:** تأكد من أن رابط الصورة أو العنصر الأساسي موجود مباشرة في كود HTML (باستخدام `<img src=\"...\">` أو `<link rel=\"preload\">`) حتى يتمكن المتصفح من اكتشافه وتحميله مبكراً دون انتظار تنفيذ ملفات JavaScript أو CSS.\n*   **استخدم `fetchpriority=\"high\"`:** أعطِ أولوية عالية للعنصر الأساسي (LCP element) عن طريق إضافة هذا الوسم، مما يخبر المتصفح بضرورة تحميله قبل الموارد الأخرى الأقل أهمية.\n*   **تجنب التحميل الكسول (Lazy Loading) للعنصر الأساسي:** لا تستخدم `loading=\"lazy\"` على الصورة أو العنصر الذي يمثل LCP، لأن هذا يؤخر تحميله.\n*   **استخدم شبكة توصيل المحتوى (CDN):** تقلل الـ CDN من زمن استجابة الخادم (TTFB) عن طريق توزيع المحتوى على خوادم أقرب جغرافياً للمستخدمين.\n*   **استخدم التخزين المؤقت (Caching):** قم بتفعيل التخزين المؤقت للموارد الثابتة لتقليل أوقات التحميل للمستخدمين العائدين.\n\n#### 2. تحسين Interaction to Next Paint (INP)\n\n*   **تقسيم المهام الطويلة (Long Tasks):** أي مهمة JavaScript تستغرق أكثر من 50 مللي ثانية يمكن أن تمنع المتصفح من الاستجابة للمستخدم. قم بتقسيم هذه المهام إلى أجزاء أصغر باستخدام تقنيات مثل `setTimeout` أو `requestIdleCallback` أو `scheduler.yield()` للسماح للمتصفح بمعالجة تفاعلات المستخدم بين المهام.\n*   **تجنب JavaScript غير الضروري:** قم بمراجعة وتحليل الكود لإزالة أي سكربتات غير مستخدمة. استخدم أدوات مثل \"Coverage\" في Chrome DevTools لتحديد الكود غير المستخدم.\n*   **تجنب التحديثات الكبيرة للتخطيط (Large Rendering Updates):** قلل من تعقيد الـ DOM وحجمه. التغييرات في DOM كبير تتطلب عملًا حسابيًا أكبر من المتصفح لإعادة رسم الصفحة. استخدم تقنية \"CSS Containment\" لعزل أجزاء من الصفحة وتجنب إعادة الحسابات غير الضرورية.\n\n#### 3. تحسين Cumulative Layout Shift (CLS)\n\n*   **حدد أبعادًا صريحة للصور والفيديوهات:** دائمًا قم بتضمين سمات `width` و `height` في وسوم `<img>` و `<video>`. بدلاً من ذلك، استخدم خاصية `aspect-ratio` في CSS للحفاظ على المساحة المخصصة للعنصر قبل تحميله.\n*   **تجنب إدراج المحتوى ديناميكيًا فوق المحتوى الحالي:** إذا كنت بحاجة إلى إضافة محتوى جديد للصفحة (مثل الإعلانات أو التنبيهات)، فاحجز له مساحة مسبقًا لتجنب دفع المحتوى الآخر لأسفل.\n*   **استخدم تحويلات CSS بدلاً من الرسوم المتحركة التي تؤثر على التخطيط:** استخدم خصائص مثل `transform: translate()` بدلاً من تغيير خصائص مثل `top` أو `left` أو `margin` لتحريك العناصر، لأن `transform` لا يؤدي إلى إعادة حساب تخطيط الصفحة.\n*   **تأكد من أن الصفحات مؤهلة للتخزين المؤقت (bfcache):** الـ Back/forward cache يسمح بتحميل الصفحات السابقة واللاحقة بشكل فوري. تجنب استخدام `unload` event listeners وتوجيهات `no-store` caching لضمان عمله.",
        "tools_technologies": "### أدوات وتقنيات أساسية لتحسين أداء المواقع\n\nلتحقيق أفضل أداء ممكن لموقعك، من الضروري استخدام مجموعة من الأدوات والتقنيات المتخصصة التي تساعد في قياس، تحليل، وتحسين مختلف جوانب السرعة وتجربة المستخدم. فيما يلي قائمة بأهم هذه الأدوات والتقنيات:\n\n| الأداة / التقنية | الوصف |\n|---|---|\n| **Google PageSpeed Insights** | أداة مجانية من جوجل تحلل أداء صفحة الويب على كل من أجهزة الجوال وسطح المكتب. تقدم تقريراً مفصلاً عن مؤشرات أداء الويب الأساسية (Core Web Vitals) بالإضافة إلى اقتراحات عملية لتحسينها. |\n| **Google Lighthouse** | أداة مطورين مدمجة في متصفح جوجل كروم (ومتوافرة كأداة سطر أوامر) تقوم بإجراء عمليات تدقيق شاملة للصفحة في خمسة مجالات رئيسية: الأداء، إمكانية الوصول، أفضل الممارسات، تحسين محركات البحث (SEO)، وتطبيق الويب التقدمي (PWA). |\n| **WebPageTest** | أداة اختبار أداء متقدمة تسمح بإجراء اختبارات من مواقع جغرافية مختلفة وباستخدام متصفحات وسرعات اتصال متنوعة. توفر رسومًا بيانية مفصلة (Waterfall charts) توضح كيفية تحميل كل مورد على الصفحة. |\n| **Chrome DevTools (أدوات مطوري كروم)** | مجموعة قوية من أدوات تصحيح الأخطاء والتطوير المدمجة في متصفح كروم. يحتوي قسم \"Performance\" على أدوات لتحليل أداء وقت التشغيل (runtime performance) وتحديد المهام الطويلة (Long Tasks) التي تعيق الاستجابة. |\n| **Webpack Bundle Analyzer** | أداة مساعدة لـ Webpack تقوم بتحليل حزمة الكود (bundle) الخاصة بك وتصور محتوياتها في مخطط شجري تفاعلي. تساعد هذه الأداة في تحديد المكتبات الكبيرة أو المكررة التي تزيد من حجم الحزمة. |\n| **شبكات توصيل المحتوى (CDNs)** | خدمات مثل Cloudflare, Akamai, و Amazon CloudFront تقوم بتخزين نسخ من محتوى موقعك (الصور، ملفات CSS, JavaScript) على خوادم موزعة عالميًا. هذا يقلل بشكل كبير من وقت الوصول إلى الموارد عن طريق خدمتها من أقرب موقع جغرافي للمستخدم. |\n| **Babel** | مترجم JavaScript يستخدم بشكل أساسي لتحويل كود ECMAScript 2015+ (ES6+) إلى إصدار متوافق مع المتصفحات القديمة. يمكن استخدامه أيضًا لتحسين الكود وإزالة الميزات غير الضرورية. |\n| **PostCSS** | أداة لتحويل أنماط CSS باستخدام إضافات (plugins) تعمل بـ JavaScript. يمكن استخدامها لتطبيق بادئات المتصفحات (autoprefixer)، وتصغير الكود، وتطبيق تقنيات متقدمة مثل Critical CSS. |",
        "code_examples": "### أمثلة كود عملية لتحسين الأداء\n\nفيما يلي أمثلة توضيحية لكيفية تطبيق بعض أهم تقنيات تحسين سرعة المواقع.\n\n#### 1. التحميل الكسول للصور (Lazy Loading)\n\nهذه هي الطريقة الأسهل والأكثر حداثة لتطبيق التحميل الكسول، وهي مدعومة الآن في معظم المتصفحات الرئيسية. ببساطة، أضف السمة `loading=\"lazy\"` إلى وسوم الصور والفيديوهات.\n\n```html\n<!-- الصورة لن يتم تحميلها إلا عندما يقترب المستخدم من رؤيتها في الصفحة -->\n<img src=\"image.jpg\" alt=\"وصف الصورة\" loading=\"lazy\" width=\"200\" height=\"200\">\n\n<!-- التحميل الكسول لإطار iframe -->\n<iframe src=\"https://www.youtube.com/embed/xxxxxxxxxxx\" title=\"فيديو يوتيوب\" loading=\"lazy\"></iframe>\n```\n**الشرح:** السمة `loading=\"lazy\"` تخبر المتصفح بتأجيل تحميل المورد (صورة أو iframe) حتى يدخل في نطاق العرض (viewport) الخاص بالمستخدم. هذا يقلل بشكل كبير من استهلاك البيانات ويسرع التحميل الأولي للصفحة.\n\n#### 2. التحميل المسبق للموارد الحرجة (Preloading)\n\nاستخدم `<link rel=\"preload\">` لإخبار المتصفح ببدء تحميل الموارد الهامة في أقرب وقت ممكن، مثل خطوط الويب الرئيسية أو صورة الـ LCP.\n\n```html\n<head>\n  <meta charset=\"UTF-8\">\n  <title>مثال على التحميل المسبق</title>\n\n  <!-- تحميل مسبق لملف خط رئيسي -->\n  <link rel=\"preload\" href=\"/fonts/my-critical-font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n\n  <!-- تحميل مسبق لصورة الـ LCP -->\n  <link rel=\"preload\" href=\"/images/lcp-hero-image.webp\" as=\"image\">\n</head>\n```\n**الشرح:** `rel=\"preload\"` يبدأ عملية التحميل مبكراً. السمة `as` تخبر المتصفح بنوع المورد، مما يسمح له بتحديد أولوية التحميل بشكل صحيح وتطبيق سياسات أمان المحتوى المناسبة.\n\n#### 3. تحديد أولوية التحميل باستخدام `fetchpriority`\n\nيمكنك إعطاء تلميح للمتصفح حول أهمية مورد معين. هذا مفيد بشكل خاص لإعطاء أولوية قصوى لصورة الـ LCP.\n\n```html\n<!-- إعطاء أولوية عالية لصورة البطل (Hero Image) التي تمثل LCP -->\n<img src=\"hero.jpg\" alt=\"صورة رئيسية\" fetchpriority=\"high\">\n\n<!-- إعطاء أولوية منخفضة لصورة ثانوية في الجزء السفلي من الصفحة -->\n<img src=\"secondary-image.jpg\" alt=\"صورة ثانوية\" fetchpriority=\"low\">\n```\n**الشرح:** `fetchpriority=\"high\"` تزيد من أولوية تحميل المورد، بينما `fetchpriority=\"low\"` تقلل من أولويته. هذا يساعد المتصفح على تخصيص النطاق الترددي للموارد الأكثر أهمية أولاً.\n\n#### 4. تقسيم الكود (Code Splitting) باستخدام Dynamic `import()`\n\nبدلاً من تحميل كل كود JavaScript في حزمة واحدة كبيرة، يمكنك تحميل أجزاء من الكود فقط عند الحاجة إليها، على سبيل المثال، عند تفاعل المستخدم مع عنصر معين.\n\n```javascript\n// زر عند النقر عليه، يقوم بتحميل وحدة (module) خاصة بالرسم البياني\nconst chartButton = document.getElementById(\"show-chart-button\");\n\nchartButton.addEventListener(\"click\", () => {\n  // لن يتم تحميل \"chart-library.js\" إلا بعد النقر على الزر\n  import(\"./modules/chart-library.js\")\n    .then(module => {\n      const Chart = module.default;\n      const myChart = new Chart(/* ... config ... */);\n      myChart.draw();\n    })\n    .catch(err => {\n      console.error(\"فشل تحميل وحدة الرسم البياني:\", err);\n    });\n});\n```\n**الشرح:** `import()` هي دالة ديناميكية تُرجع Promise. عندما يتم استدعاؤها، فإنها تقوم بتحميل الوحدة المحددة بشكل غير متزامن. هذا يقلل من حجم الحزمة الأولية (initial bundle) ويحسن وقت بدء تشغيل التطبيق (startup time).",
        "practical_tips": "### نصائح عملية لتحسين فوري لأداء موقعك\n\n1.  **اضغط صورك بذكاء:** قبل رفع أي صورة إلى موقعك، استخدم أدوات مثل Squoosh أو ImageOptim لضغطها دون فقدان جودة ملحوظ. اختر التنسيق المناسب (WebP للصور الحديثة، JPEG للصور الفوتوغرافية، PNG للأيقونات ذات الشفافية). لا تقم برفع صور بأبعاد أكبر من تلك التي ستُعرض بها على الشاشة.\n\n2.  **فعل التخزين المؤقت للمتصفح (Browser Caching):** قم بتهيئة خادم الويب الخاص بك لإرسال ترويسات (headers) التخزين المؤقت المناسبة. هذا يخبر متصفحات الزوار بتخزين الموارد الثابتة (CSS, JS, الصور) محليًا، مما يجعل الزيارات المتكررة أسرع بشكل كبير.\n\n3.  **قم بتصغير (Minify) ملفات CSS و JavaScript:** قم بإزالة جميع الأحرف غير الضرورية (المسافات، الفواصل، التعليقات) من ملفات الكود الخاصة بك. معظم أدوات بناء المشاريع (مثل Webpack, Vite) تقوم بذلك تلقائيًا في وضع الإنتاج (production mode).\n\n4.  **استخدم شبكة توصيل المحتوى (CDN):** حتى لو كان موقعك صغيرًا، فإن استخدام CDN (مثل Cloudflare الذي يقدم خطة مجانية) يمكن أن يحدث فرقًا كبيرًا في سرعة التحميل للمستخدمين حول العالم ويقلل العبء على الخادم الرئيسي.\n\n5.  **أجل تحميل JavaScript قدر الإمكان:** أضف السمة `defer` إلى وسوم `<script>` الخاصة بك. هذا يجعل المتصفح يقوم بتحميل ملفات JavaScript بالتوازي مع تحليل الصفحة، ويقوم بتنفيذها فقط بعد اكتمال بناء الـ DOM، مما يمنعها من إعاقة العرض الأولي للصفحة.\n\n6.  **حدد أبعاد الصور والفيديوهات دائمًا:** لتجنب حدوث تغيرات في التخطيط (CLS)، قم دائمًا بتضمين سمات `width` و `height` في وسوم `<img>` و `<video>` أو استخدم خاصية `aspect-ratio` في CSS.\n\n7.  **قم بتحليل حزمة JavaScript الخاصة بك:** استخدم أداة مثل `webpack-bundle-analyzer` لتفحص ما يوجد داخل حزمة JavaScript النهائية. قد تتفاجأ من وجود مكتبات كبيرة أو مكررة يمكنك إزالتها أو استبدالها ببدائل أصغر.\n\n8.  **استضف الخطوط محليًا:** بدلاً من استيراد الخطوط من خدمات مثل Google Fonts مباشرة، قم بتنزيل ملفات الخطوط (بتنسيق WOFF2) واستضفها على الخادم الخاص بك. هذا يمنحك تحكمًا أكبر في كيفية تحميلها ويقلل من عدد طلبات DNS الخارجية.",
        "common_mistakes": "### أخطاء شائعة يجب تجنبها عند تحسين أداء المواقع\n\n1.  **الخطأ: تجاهل أداء نسخة الجوال.**\n    *   **المشكلة:** يركز العديد من المطورين على اختبار الأداء على أجهزة الكمبيوتر المكتبية القوية واتصالات الإنترنت السريعة، بينما غالبية المستخدمين يتصفحون من خلال أجهزة جوال أبطأ وشبكات غير مستقرة.\n    *   **الحل:** اجعل اختبار الأداء على الجوال هو الأولوية. استخدم أدوات مثل Google PageSpeed Insights و Chrome DevTools لمحاكاة ظروف الشبكة والأجهزة المحمولة.\n\n2.  **الخطأ: تحميل جميع الصور والوسائط دفعة واحدة.**\n    *   **المشكلة:** عدم استخدام التحميل الكسول (Lazy Loading) للصور والفيديوهات الموجودة خارج إطار العرض الأولي يؤدي إلى إهدار النطاق الترددي وتأخير تحميل المحتوى الهام.\n    *   **الحل:** طبق التحميل الكسول لجميع الصور والفيديوهات غير الحرجة. استخدم السمة `loading=\"lazy\"` للحصول على حل بسيط وفعال.\n\n3.  **الخطأ: عدم تحديد أبعاد الصور والإعلانات.**\n    *   **المشكلة:** عندما لا يتم تحديد مساحة للصور أو الإعلانات مسبقًا، يقوم المتصفح بتحميلها ثم يغير تخطيط الصفحة فجأة لاستيعابها، مما يسبب قفزات مزعجة في المحتوى (CLS عالٍ).\n    *   **الحل:** دائمًا قم بتضمين سمات `width` و `height` في وسوم `<img>` و `<video>`، أو استخدم خاصية `aspect-ratio` في CSS. بالنسبة للإعلانات، احجز لها مساحة ثابتة في التخطيط.\n\n4.  **الخطأ: استخدام حزم JavaScript ضخمة ومتجانسة.**\n    *   **المشكلة:** تحميل ملف JavaScript واحد كبير يمنع التفاعل مع الصفحة حتى يتم تحميله وتحليله وتنفيذه بالكامل، مما يؤدي إلى ارتفاع زمن INP.\n    *   **الحل:** استخدم تقنيات تقسيم الكود (Code Splitting) لتقسيم الحزمة إلى أجزاء أصغر يتم تحميلها عند الحاجة فقط. استخدم Dynamic `import()` لتحميل الوحدات بشكل غير متزامن.\n\n5.  **الخطأ: تجاهل أهمية التخزين المؤقت (Caching).**\n    *   **المشكلة:** عدم تفعيل التخزين المؤقت يجبر المتصفح على إعادة تحميل جميع الموارد (CSS, JS, الصور) في كل مرة يزور فيها المستخدم صفحة جديدة أو يعود إلى الموقع، مما يبطئ التجربة بشكل كبير.\n    *   **الحل:** قم بتهيئة الخادم لإرسال ترويسات `Cache-Control` المناسبة، مما يسمح للمتصفح بتخزين الموارد الثابتة محليًا لفترات طويلة.\n\n6.  **الخطأ: إجراء عمليات حسابية معقدة أو تحديثات DOM متكررة في الجانب العميل.**\n    *   **المشكلة:** المهام الطويلة (Long Tasks) في JavaScript، سواء كانت حسابات معقدة أو تلاعبًا متكررًا بالـ DOM، تمنع الخيط الرئيسي (Main Thread) من الاستجابة لتفاعلات المستخدم.\n    *   **الحل:** انقل الحسابات المعقدة إلى خادم الويب (Server-side) أو استخدم Web Workers لتشغيلها في خيط منفصل. قم بتجميع تحديثات الـ DOM وتطبيقها دفعة واحدة لتجنب \"layout thrashing\".",
        "checklist": "### قائمة تحقق سريعة لضمان أداء وسرعة الموقع\n\nاستخدم قائمة التحقق هذه لمراجعة أهم النقاط التي تضمن تطبيق معايير الأداء الأساسية:\n\n**تحسين LCP (سرعة التحميل):**\n- [ ] هل تم ضغط جميع الصور وتحسينها؟\n- [ ] هل تستخدم تنسيق WebP للصور حيثما أمكن؟\n- [ ] هل صورة الـ LCP (أكبر عنصر مرئي) قابلة للاكتشاف مباشرة من كود HTML؟\n- [ ] هل تم إعطاء أولوية تحميل عالية (`fetchpriority=\"high\"`) لصورة الـ LCP؟\n- [ ] هل تم تجنب التحميل الكسول (`loading=\"lazy\"`) لصورة الـ LCP؟\n- [ ] هل تستخدم شبكة توصيل المحتوى (CDN) لخدمة الموارد الثابتة؟\n- [ ] هل تم تفعيل التخزين المؤقت للمتصفح (Browser Caching) بشكل صحيح؟\n\n**تحسين INP (سرعة الاستجابة):**\n- [ ] هل تم تحليل أداء JavaScript لتحديد المهام الطويلة (Long Tasks)؟\n- [ ] هل تم تقسيم المهام الطويلة إلى أجزاء أصغر؟\n- [ ] هل تم تأجيل تحميل وتنفيذ JavaScript غير الضروري باستخدام `defer` أو `async`؟\n- [ ] هل تم استخدام تقسيم الكود (Code Splitting) لتقليل حجم الحزمة الأولية؟\n- [ ] هل حجم الـ DOM معقول وغير متضخم بشكل مفرط؟\n\n**تحسين CLS (الاستقرار البصري):**\n- [ ] هل تم تحديد أبعاد (`width` و `height`) لجميع الصور والفيديوهات؟\n- [ ] هل تم حجز مساحة كافية للمحتوى الذي يتم تحميله ديناميكيًا (مثل الإعلانات)؟\n- [ ] هل يتم تجنب إدراج محتوى جديد فوق المحتوى الموجود؟\n- [ ] هل يتم استخدام تحويلات CSS (`transform`) للرسوم المتحركة بدلاً من الخصائص التي تؤثر على التخطيط (مثل `margin`, `top`)؟\n\n**ممارسات عامة:**\n- [ ] هل تم تصغير (Minify) جميع ملفات CSS و JavaScript؟\n- [ ] هل يتم تحميل الخطوط بكفاءة (استضافة محلية، تنسيق WOFF2)؟\n- [ ] هل تم اختبار الموقع على أجهزة جوال وشبكات بطيئة؟",
        "sources": "### المصادر والمراجع\n\n1.  **[Understanding Core Web Vitals and Google search results](https://developers.google.com/search/docs/appearance/core-web-vitals)** - Google Search Central\n2.  **[The most effective ways to improve Core Web Vitals](https://web.dev/articles/top-cwv)** - web.dev\n3.  **[Web Vitals](https://web.dev/articles/vitals)** - web.dev\n4.  **[Learn about the three Core Web Vitals: LCP, FID & CLS](https://yoast.com/core-web-vitals/)** - Yoast\n5.  **[Lighthouse: Optimize your website | Chrome DevTools](https://developer.chrome.com/docs/devtools/lighthouse)** - Chrome for Developers"
      },
      "error": ""
    },
    {
      "input": "أفضل ممارسات قواعد البيانات: Database Indexing, Query Optimization, Connection Pooling, Caching Strategies, Database Normalization, N+1 Problem, Pagination, Database Migrations, Prisma ORM Best Practices",
      "output": {
        "topic_title": "أفضل ممارسات قواعد البيانات: دليل شامل للمطورين",
        "introduction": "في عالم تطوير البرمجيات الحديث، تمثل قواعد البيانات حجر الزاوية لأي تطبيق ناجح. إنها لا تقتصر على تخزين البيانات فحسب، بل تؤثر بشكل مباشر على أداء التطبيق، قابلية التوسع، وموثوقيته. لذلك، يعد فهم وتطبيق أفضل الممارسات في إدارة قواعد البيانات أمرًا بالغ الأهمية للمطورين والمهندسين. يهدف هذا الدليل إلى تقديم نظرة شاملة وعميقة على مجموعة من أفضل الممارسات الأساسية، بدءًا من فهرسة قواعد البيانات وتحسين الاستعلامات، وصولًا إلى استراتيجيات التخزين المؤقت والتعامل مع المشكلات الشائعة مثل مشكلة N+1. من خلال هذا الدليل، سيكتسب المطورون المعرفة اللازمة لبناء تطبيقات عالية الأداء وقابلة للتطوير، مع ضمان سلامة البيانات واتساقها.",
        "key_concepts": "_**فهرسة قواعد البيانات (Database Indexing):**_ هي تقنية لتحسين أداء استرداد البيانات من خلال إنشاء هياكل بيانات خاصة (فهارس) تسمح بالوصول السريع إلى الصفوف في جدول قاعدة البيانات.\n\n_**تحسين الاستعلامات (Query Optimization):**_ هي عملية تعديل الاستعلامات لتقليل الوقت والموارد اللازمة لتنفيذها، مما يؤدي إلى تحسين أداء قاعدة البيانات بشكل عام.\n\n_**تجميع الاتصالات (Connection Pooling):**_ هي تقنية لإدارة اتصالات قاعدة البيانات بكفاءة عن طريق إعادة استخدام مجموعة من الاتصالات الموجودة بدلاً من إنشاء اتصالات جديدة لكل طلب.\n\n_**استراتيجيات التخزين المؤقت (Caching Strategies):**_ هي تقنيات لتخزين البيانات التي يتم الوصول إليها بشكل متكرر في ذاكرة مؤقتة (ذاكرة التخزين المؤقت) لتسريع عمليات القراءة المستقبلية.\n\n_**تسوية قواعد البيانات (Database Normalization):**_ هي عملية تنظيم أعمدة وجداول قاعدة بيانات علائقية لتقليل تكرار البيانات وتحسين سلامة البيانات.\n\n_**مشكلة N+1 (N+1 Problem):**_ هي مشكلة أداء شائعة تحدث عندما يقوم التطبيق بإجراء استعلام واحد لجلب قائمة من العناصر، ثم يقوم بإجراء استعلامات إضافية (N) لكل عنصر في القائمة لجلب البيانات ذات الصلة.\n\n_**ترقيم الصفحات (Pagination):**_ هي عملية تقسيم مجموعة كبيرة من النتائج إلى صفحات منفصلة، مما يسهل على المستخدمين التنقل عبر البيانات ويحسن أداء التطبيق.\n\n_**ترحيل قواعد البيانات (Database Migrations):**_ هي عملية إدارة التغييرات على مخطط قاعدة البيانات بطريقة منظمة ومنضبطة، مما يسمح بتطور المخطط جنبًا إلى جنب مع تطور التطبيق.\n\n_**Prisma ORM:**_ هو ORM (Object-Relational Mapper) من الجيل التالي لـ Node.js و TypeScript يساعد المطورين على بناء تطبيقات أسرع وأكثر أمانًا من خلال توفير طبقة تجريد آمنة للكتابة فوق قاعدة البيانات.",
        "best_practices": "## أفضل ممارسات قواعد البيانات: دليل شامل للمطورين\n\n### فهرسة قواعد البيانات (Database Indexing)\n\nالفهرسة هي تقنية أساسية لتحسين أداء استرداد البيانات من خلال إنشاء هياكل بيانات خاصة (فهارس) تسمح بالوصول السريع إلى الصفوف في جدول قاعدة البيانات. تعمل الفهارس مثل فهرس الكتاب، حيث تسمح لمحرك قاعدة البيانات بتحديد موقع البيانات المطلوبة بسرعة دون الحاجe إلى فحص كل صف في الجدول. يؤدي ذلك إلى تحسين أداء الاستعلامات بشكل كبير، خاصة مع زيادة حجم البيانات.\n\n### تحسين الاستعلامات (Query Optimization)\n\nتحسين الاستعلامات هو عملية تعديل الاستعلامات لتقليل الوقت والموارد اللازمة لتنفيذها. يتضمن ذلك اختيار خطة التنفيذ الأكثر كفاءة للاستعلام، والتي تحدد كيفية وصول قاعدة البيانات إلى البيانات المطلوبة. يمكن أن يشمل ذلك استخدام الفهارس بشكل فعال، وتجنب الاستعلامات الفرعية غير الضرورية، وإعادة كتابة الاستعلامات لتكون أكثر كفاءة.\n\n### تجميع الاتصالات (Connection Pooling)\n\nتجميع الاتصالات هو تقنية لإدارة اتصالات قاعدة البيانات بكفاءة عن طريق إعادة استخدام مجموعة من الاتصالات الموجودة بدلاً من إنشاء اتصالات جديدة لكل طلب. يقلل هذا من الحمل على قاعدة البيانات ويحسن أداء التطبيق بشكل كبير، خاصة في التطبيقات ذات حركة المرور العالية.\n\n### استراتيجيات التخزين المؤقت (Caching Strategies)\n\nاستراتيجيات التخزين المؤقت هي تقنيات لتخزين البيانات التي يتم الوصول إليها بشكل متكرر في ذاكرة مؤقتة (ذاكرة التخزين المؤقت) لتسريع عمليات القراءة المستقبلية. هناك العديد من الاستراتيجيات المختلفة، مثل Cache-aside و Read-through و Write-through، ولكل منها مزاياها وعيوبها اعتمادًا على حالة الاستخدام.\n\n### تسوية قواعد البيانات (Database Normalization)\n\nتسوية قواعد البيانات هي عملية تنظيم أعمدة وجداول قاعدة بيانات علائقية لتقليل تكرار البيانات وتحسين سلامة البيانات. تتبع التسوية سلسلة من الأشكال العادية (Normal Forms)، حيث يكون الشكل الطبيعي الثالث (3NF) هو الأكثر شيوعًا في التطبيقات العملية.\n\n### مشكلة N+1 (N+1 Problem)\n\nمشكلة N+1 هي مشكلة أداء شائعة تحدث عندما يقوم التطبيق بإجراء استعلام واحد لجلب قائمة من العناصر، ثم يقوم بإجراء استعلامات إضافية (N) لكل عنصر في القائمة لجلب البيانات ذات الصلة. يمكن حل هذه المشكلة عن طريق استخدام جمل `JOIN` أو ميزات ORM مثل `include` في Prisma لجلب جميع البيانات المطلوبة في استعلام واحد.\n\n### ترقيم الصفحات (Pagination)\n\nترقيم الصفحات هو عملية تقسيم مجموعة كبيرة من النتائج إلى صفحات منفصلة، مما يسهل على المستخدمين التنقل عبر البيانات ويحسن أداء التطبيق. هناك نوعان رئيسيان من ترقيم الصفحات: ترقيم الصفحات بالإزاحة (offset pagination) وترقيم الصفحات بالمؤشر (cursor pagination)، حيث يعتبر الأخير أكثر كفاءة لمجموعات البيانات الكبيرة.\n\n### ترحيل قواعد البيانات (Database Migrations)\n\nترحيل قواعد البيانات هو عملية إدارة التغييرات على مخطط قاعدة البيانات بطريقة منظمة ومنضبطة. تسمح أدوات مثل Liquibase و Flyway للمطورين بتتبع تغييرات المخطط وتطبيقها بشكل موثوق عبر بيئات مختلفة.\n\n### أفضل ممارسات Prisma ORM\n\nPrisma هو ORM حديث لـ Node.js و TypeScript. تتضمن أفضل الممارسات عند استخدامه تجنب إنشاء مثيلات متعددة من العميل، وإدارة المخطط مركزيًا في المستودعات الأحادية، واستخدام ميزاته لتحسين أداء الاستعلام.",
        "tools_technologies": "*   **Prisma:** ORM (Object-Relational Mapper) حديث لـ Node.js و TypeScript يسهل التعامل مع قواعد البيانات.\n*   **Liquibase:** أداة مفتوحة المصدر لإدارة ترحيل مخططات قواعد البيانات وتتبع التغييرات.\n*   **Flyway:** أداة أخرى شائعة لترحيل قواعد البيانات تعتمد على SQL.\n*   **pgBouncer:** بروكسي لتجميع الاتصالات (Connection Pooler) لقاعدة بيانات PostgreSQL.\n*   **Redis:** مخزن بيانات في الذاكرة يستخدم غالبًا كذاكرة تخزين مؤقت (Cache) عالية الأداء.\n*   **Memcached:** نظام تخزين مؤقت للكائنات الموزعة في الذاكرة، يستخدم لتسريع التطبيقات الديناميكية.\n*   **EXPLAIN (في SQL):** أداة مدمجة في معظم أنظمة قواعد البيانات لتحليل خطة تنفيذ الاستعلام وتحديد نقاط الضعف في الأداء.",
        "code_examples": "## مثال على استخدام Prisma لتجنب مشكلة N+1\n\n```typescript\n// طريقة غير فعالة (N+1)\nconst users = await prisma.user.findMany();\nconst posts = await Promise.all(\n  users.map(user => prisma.post.findMany({ where: { authorId: user.id } }))\n);\n\n// الطريقة الصحيحة والفعالة\nconst usersWithPosts = await prisma.user.findMany({\n  include: { posts: true },\n});\n```\n\n## مثال على ترحيل قاعدة البيانات باستخدام Liquibase\n\n```xml\n<!-- changeset example in XML format -->\n<changeSet id=\"1\" author=\"liquibase\">\n  <createTable tableName=\"person\">\n    <column name=\"id\" type=\"int\" autoIncrement=\"true\">\n      <constraints primaryKey=\"true\" nullable=\"false\"/>\n    </column>\n    <column name=\"name\" type=\"varchar(50)\">\n      <constraints nullable=\"false\"/>\n    </column>\n    <column name=\"address1\" type=\"varchar(50)\"/>\n    <column name=\"address2\" type=\"varchar(50)\"/>\n    <column name=\"city\" type=\"varchar(30)\"/>\n  </createTable>\n</changeSet>\n```\n\n## مثال على ترقيم الصفحات بالمؤشر (Cursor Pagination)\n\n```sql\n-- جلب الصفحة الأولى\nSELECT * FROM posts ORDER BY id LIMIT 10;\n\n-- جلب الصفحة التالية باستخدام مؤشر\nSELECT * FROM posts WHERE id > (last_id_from_previous_page) ORDER BY id LIMIT 10;\n```",
        "practical_tips": "1.  **استخدم الفهارس بحكمة:** لا تفرط في استخدام الفهارس لأنها تبطئ عمليات الكتابة. قم بفهرسة الأعمدة المستخدمة بشكل متكرر في جمل `WHERE` و `JOIN`.\n2.  **حلل استعلاماتك:** استخدم `EXPLAIN` بانتظام لفهم كيفية تنفيذ استعلاماتك وتحديد الاختناقات.\n3.  **اختر استراتيجية التخزين المؤقت المناسبة:** لا توجد استراتيجية واحدة تناسب الجميع. اختر الاستراتيجية (مثل Cache-aside أو Read-through) التي تناسب نمط وصول تطبيقك للبيانات.\n4.  **قم بتسوية قاعدة بياناتك، ولكن كن عمليًا:** ابدأ بالشكل الطبيعي الثالث (3NF) وفكر في إلغاء التسوية بشكل استراتيجي فقط عند الضرورة لتحسين أداء القراءة.\n5.  **كن على دراية بمشكلة N+1:** استخدم أدوات مثل Prisma's `include` أو `JOIN` في SQL لجلب البيانات ذات الصلة بكفاءة.\n6.  **فضل ترقيم الصفحات بالمؤشر:** خاصة للتطبيقات التي تحتوي على بيانات في الوقت الفعلي أو مجموعات بيانات كبيرة جدًا، حيث يوفر أداءً أفضل واتساقًا للبيانات.\n7.  **أتمتة عمليات ترحيل قاعدة البيانات:** استخدم أدوات مثل Liquibase أو Flyway لإدارة تغييرات المخطط بشكل موثوق ومتكرر.\n8.  **إدارة الاتصالات بفعالية:** استخدم دائمًا مجمّع اتصالات (Connection Pooler) في بيئات الإنتاج لتجنب الحمل الزائد لإنشاء الاتصالات.",
        "common_mistakes": "*   **إهمال الفهرسة:** يؤدي عدم وجود فهارس مناسبة إلى عمليات فحص كاملة للجدول، وهو أمر بطيء للغاية بالنسبة لمجموعات البيانات الكبيرة.\n*   **كتابة استعلامات غير فعالة:** جلب أعمدة غير ضرورية (`SELECT *`) أو استخدام `JOIN` بشكل غير صحيح يمكن أن يضر بالأداء.\n*   **عدم استخدام تجميع الاتصالات:** يؤدي فتح وإغلاق الاتصالات لكل تفاعل مع قاعدة البيانات إلى إهدار الموارد وإبطاء التطبيق.\n*   **تجاهل التخزين المؤقت:** يؤدي عدم تخزين البيانات التي يتم الوصول إليها بشكل متكرر إلى زيادة الحمل على قاعدة البيانات دون داع.\n*   **الإفراط في التسوية أو نقصها:** يمكن أن يؤدي كلاهما إلى مشكلات. يؤدي الإفراط في التسوية إلى استعلامات معقدة، بينما يؤدي نقصها إلى تكرار البيانات وعدم اتساقها.\n*   **الوقوع في فخ N+1:** الفشل في تحميل البيانات ذات الصلة بشكل استباقي يؤدي إلى عدد كبير من الاستعلامات غير الضرورية.\n*   **استخدام ترقيم الصفحات بالإزاحة على مجموعات البيانات الكبيرة:** يمكن أن يصبح هذا بطيئًا بشكل كبير مع تصفح المستخدم للصفحات العميقة.\n*   **إجراء تغييرات يدوية على مخطط قاعدة البيانات:** هذا عرضة للخطأ ويجعل من الصعب تتبع التغييرات وإعادة إنتاج البيئات.",
        "checklist": "- [ ] هل الأعمدة المستخدمة في جمل `WHERE` و `JOIN` مفهرسة؟\n- [ ] هل تم تحليل الاستعلامات المعقدة باستخدام `EXPLAIN`؟\n- [ ] هل يتم استخدام تجميع الاتصالات في بيئة الإنتاج؟\n- [ ] هل توجد استراتيجية تخزين مؤقت للبيانات التي يتم قراءتها بشكل متكرر؟\n- [ ] هل تصميم قاعدة البيانات يتبع على الأقل الشكل الطبيعي الثالث (3NF)؟\n- [ ] هل يتم تجنب مشكلة N+1 عن طريق التحميل المسبق للبيانات ذات الصلة؟\n- [ ] هل يتم استخدام ترقيم الصفحات بالمؤشر (Cursor Pagination) لمجموعات البيانات الكبيرة؟\n- [ ] هل يتم إدارة تغييرات مخطط قاعدة البيانات من خلال أداة ترحيل آلية؟\n- [ ] هل يتم استخدام ORM مثل Prisma بشكل صحيح لتجنب إنشاء مثيلات متعددة؟",
        "sources": "*   [GeeksforGeeks - Indexing in Databases](https://www.geeksforgeeks.org/dbms/indexing-in-databases-set-1/)\n*   [DataCamp - SQL Query Optimization](https://www.datacamp.com/blog/sql-query-optimization)\n*   [Architecture Weekly - Mastering Connection Pooling](https://www.architecture-weekly.com/p/architecture-weekly-189-mastering)\n*   [Prisma - Database Caching](https://www.prisma.io/dataguide/managing-databases/introduction-database-caching)\n*   [Microsoft Learn - Database Normalization](https://learn.microsoft.com/en-us/troubleshoot/microsoft-365-apps/access/database-normalization-description)\n*   [PlanetScale - N+1 Query Problem](https://planetscale.com/blog/what-is-n-1-query-problem-and-how-to-solve-it)\n*   [Appwrite - Best Pagination Technique](https://appwrite.io/blog/post/best-pagination-technique)\n*   [Liquibase - Database Schema Migration](https://www.liquibase.com/resources/guides/database-schema-migration)\n*   [Prisma - Using Prisma with Next.js](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/nextjs-help)\n"
      },
      "error": ""
    },
    {
      "input": "التصميم المتجاوب Responsive Design: Mobile First Approach, CSS Media Queries, Flexible Grids, Fluid Typography, Touch Optimization, Progressive Enhancement, Viewport Meta Tag, CSS Container Queries",
      "output": {
        "topic_title": "التصميم المتجاوب (Responsive Design): دليل شامل للمطورين",
        "introduction": "يمثل التصميم المتجاوب (Responsive Web Design) اليوم حجر الزاوية في تطوير الويب الحديث، حيث لم يعد تصفح الإنترنت مقتصراً على شاشات الحواسيب المكتبية. مع الانتشار الهائل للهواتف الذكية والأجهزة اللوحية والساعات الذكية وغيرها، أصبح من الضروري أن تتكيف المواقع الإلكترونية مع مختلف أحجام الشاشات ودرجات الدقة. يهدف هذا النهج إلى توفير تجربة مستخدم مثالية للجميع، بغض النظر عن الجهاز المستخدم للوصول إلى المحتوى. من خلال استخدام تقنيات مرنة مثل استعلامات الوسائط (Media Queries) والشبكات المرنة (Flexible Grids)، يضمن التصميم المتجاوب أن يظل الموقع سهل الاستخدام والقراءة والتصفح. إن تبني فلسفة \"الجوال أولاً\" (Mobile-First) والتحسين التدريجي لا يعزز فقط من تجربة المستخدم، بل يساهم أيضاً في تحسين أداء الموقع وترتيبه في محركات البحث، مما يجعله ضرورة لا غنى عنها لأي مشروع ناجح على الويب.",
        "key_concepts": "لفهم التصميم المتجاوب بعمق، لا بد من الإلمام بمجموعة من المفاهيم والمصطلحات الأساسية التي تشكل بنيته التحتية.\n\n*   **نهج الجوال أولاً (Mobile-First Approach):** فلسفة تصميم تبدأ بتصميم وتطوير نسخة الموقع المخصصة لأصغر الشاشات (الهواتف الذكية) أولاً، ثم يتم التوسع تدريجياً لإضافة تحسينات وميزات للشاشات الأكبر. هذا النهج يجبر المطورين على التركيز على المحتوى والوظائف الأساسية، مما ينتج عنه تجربة أنظف وأسرع للمستخدمين على جميع الأجهزة.\n\n*   **استعلامات الوسائط (CSS Media Queries):** هي ميزة في CSS تسمح بتطبيق مجموعات مختلفة من الأنماط بناءً على خصائص الجهاز، وأهمها عرض نافذة العرض (viewport). باستخدام استعلامات الوسائط، يمكن تغيير تخطيط الصفحة، حجم الخطوط، أو حتى إخفاء وإظهار عناصر معينة لتناسب الشاشة الحالية.\n\n*   **الشبكات المرنة (Flexible Grids):** بدلاً من استخدام وحدات قياس ثابتة (مثل البكسل) لتحديد عرض العناصر، تستخدم الشبكات المرنة وحدات نسبية (مثل النسبة المئوية أو `fr`). هذا يسمح للتخطيط بالتمدد أو التقلص بسلاسة ليناسب عرض الشاشة، محافظاً على تناسق وتوازن التصميم.\n\n*   **الطباعة السائلة (Fluid Typography):** هي تقنية تجعل حجم النصوص يتغير بسلاسة مع تغير حجم نافذة العرض، بدلاً من القفز بين أحجام ثابتة عند نقاط توقف معينة. تُستخدم لذلك وحدات مثل `vw` (عرض نافذة العرض) مع دالة `clamp()` في CSS لضمان بقاء النص قابلاً للقراءة ضمن حدود حجم معقولة.\n\n*   **تحسين اللمس (Touch Optimization):** يشير إلى تصميم عناصر الواجهة لتكون سهلة الاستخدام على الشاشات التي تعمل باللمس. يتضمن ذلك جعل الأزرار والروابط كبيرة بما يكفي للنقر عليها بسهولة، وتوفير مسافات كافية بين العناصر التفاعلية لتجنب الأخطاء.\n\n*   **التحسين التدريجي (Progressive Enhancement):** هو استراتيجية تطوير تبدأ ببناء أساس متين من المحتوى والوظائف الأساسية التي تعمل على جميع المتصفحات، ثم إضافة طبقات من التحسينات (مثل الأنماط المعقدة أو JavaScript) للمتصفحات الأكثر حداثة وقدرة. هذا يضمن إمكانية الوصول للمحتوى الأساسي للجميع.\n\n*   **وسم الميتا للـ Viewport:** هو وسم `<meta>` يوضع في رأس صفحة HTML لإخبار المتصفح بكيفية التحكم في أبعاد الصفحة وتغيير حجمها. الإعداد `width=device-width, initial-scale=1.0` هو الأكثر شيوعاً، ويضمن أن تتطابق عرض الصفحة مع عرض الجهاز.\n\n*   **استعلامات الحاوية (CSS Container Queries):** هي تقنية حديثة نسبياً تسمح للعناصر بتغيير أنماطها بناءً على حجم حاويتها (العنصر الأب) بدلاً من حجم نافذة العرض بأكملها. هذا يوفر مرونة أكبر في بناء مكونات قابلة لإعادة الاستخدام تتكيف ذاتياً مع السياق الذي توضع فيه.",
        "best_practices": "لتحقيق تصميم متجاوب فعال واحترافي، من المهم اتباع مجموعة من أفضل الممارسات التي تضمن تجربة مستخدم ممتازة وأداءً عالياً عبر جميع الأجهزة.\n\n**تبني نهج \"الجوال أولاً\" كنقطة انطلاق:**\nيعد البدء بتصميم نسخة الجوال أولاً من أهم الممارسات، حيث يجبر هذا النهج على التركيز على المحتوى الأساسي والوظائف الحيوية. يؤدي ذلك إلى تصميم مبسط وتجربة مستخدم أكثر تركيزاً. عند الانتقال إلى الشاشات الأكبر، يتم تحسين التصميم تدريجياً بإضافة ميزات إضافية بدلاً من محاولة إزالة عناصر من تصميم مكتبي معقد.\n\n**استخدام نقاط توقف (Breakpoints) مرنة:**\nبدلاً من استهداف أبعاد أجهزة معينة (مثل آيفون أو آيباد)، يجب تحديد نقاط التوقف بناءً على المحتوى نفسه. القاعدة هي: قم بتوسيع نافذة المتصفح، وعندما يبدأ التصميم في الظهور بشكل سيء أو \"مكسور\"، فهذه هي النقطة المثالية لإضافة `media query` وتعديل التخطيط. هذا يضمن أن التصميم يبدو جيداً على أي شاشة، بغض النظر عن أبعادها الدقيقة.\n\n**الاعتماد على الشبكات المرنة والوحدات النسبية:**\nيجب تجنب استخدام العروض الثابتة بالبكسل للعناصر الرئيسية في التخطيط. بدلاً من ذلك، استخدم وحدات نسبية مثل النسبة المئوية (%) أو وحدات الشبكة المرنة (`fr` في CSS Grid) و Flexbox. هذا يسمح للعناصر بالتمدد والانكماش بسلاسة مع تغير حجم الشاشة، مما يحافظ على سلامة التخطيط العام.\n\n**تحسين الصور والأصول:**\nالصور ذات الحجم الكبير هي أحد أكبر مسببات بطء تحميل الصفحات على الجوال. من الضروري تحسين الصور باستخدام تقنيات مثل الصور المتجاوبة (باستخدام `srcset` و `sizes`) لخدمة صور بأحجام مختلفة بناءً على دقة الشاشة، واستخدام صيغ الصور الحديثة مثل WebP التي توفر ضغطاً أفضل، وتطبيق التحميل الكسول (Lazy Loading) للصور التي تقع خارج نافذة العرض الأولية.\n\n**ضمان سهولة القراءة مع الطباعة السائلة:**\nيجب أن يكون النص سهل القراءة على جميع أحجام الشاشات. استخدم وحدات قياس مرنة مثل `rem` لأحجام الخطوط، والتي تتكيف مع تفضيلات حجم الخط لدى المستخدم في المتصفح. يمكن استخدام تقنيات الطباعة السائلة (Fluid Typography) باستخدام دالة `clamp()` في CSS لجعل حجم الخط يتغير بسلاسة بين حد أدنى وحد أقصى، مما يوفر تجربة قراءة مثالية.\n\n**تصميم واجهات سهلة للمس:**\nفي الأجهزة التي تعمل باللمس، الإصبع هو أداة التأشير. لذلك، يجب أن تكون الأزرار والروابط والعناصر التفاعلية الأخرى كبيرة بما يكفي (توصي Google بحجم 48x48 بكسل على الأقل) ومتباعدة بشكل كافٍ لتجنب النقرات الخاطئة. كما يجب تجنب الاعتماد على تأثيرات التمرير (hover) لعرض معلومات هامة، وتوفير بدائل تعمل باللمس.\n\n**الاختبار على أجهزة حقيقية:**\nمحاكيات المتصفح وأدوات المطورين مفيدة، لكنها لا تعكس دائماً التجربة الحقيقية للمستخدم. من الضروري اختبار الموقع على مجموعة متنوعة من الأجهزة المادية (هواتف، أجهزة لوحية) وأنظمة التشغيل المختلفة لاكتشاف المشاكل المتعلقة بالأداء، والاستجابة للمس، والفروقات في عرض الخطوط والعناصر.",
        "tools_technologies": "| الأداة / التقنية | الوصف |\n| :--- | :--- |\n| **CSS Flexbox** | نموذج تخطيط أحادي البعد يوفر طريقة فعالة لتوزيع المساحة بين العناصر في حاوية، ومحاذاتها. مثالي للمكونات الصغيرة والتخطيطات الخطية مثل قوائم التنقل. |\n| **CSS Grid** | نموذج تخطيط ثنائي الأبعاد (صفوف وأعمدة)، مما يجعله قوياً جداً في بناء تخطيطات الصفحة المعقدة والشبكات. يوفر تحكماً دقيقاً في مكان وحجم العناصر. |\n| **استعلامات الوسائط (Media Queries)** | التقنية الأساسية في CSS التي تسمح بتطبيق أنماط مختلفة بناءً على خصائص نافذة العرض مثل العرض والارتفاع والاتجاه، مما يمكن من تكييف التصميم لمختلف الشاشات. |\n| **استعلامات الحاوية (Container Queries)** | تقنية حديثة تسمح للمكونات بتكييف أنماطها بناءً على حجم حاويتها الخاصة بدلاً من نافذة العرض بأكملها، مما يعزز من قابلية إعادة استخدام المكونات. |\n| **أدوات مطوري المتصفح (Browser DevTools)** | توفر متصفحات مثل Chrome و Firefox أدوات قوية لمحاكاة مختلف أحجام الشاشات والأجهزة، وفحص وتصحيح أخطاء التخطيط، وتحليل أداء الموقع. وضع التصميم المتجاوب (Responsive Design Mode) هو أداة لا غنى عنها. |\n| **Sass / Less (معالجات CSS المسبقة)** | تسمح بكتابة CSS بطريقة أكثر تنظيماً وقابلية للصيانة من خلال استخدام المتغيرات، والـ Mixins، والدوال. يمكن استخدامها لمركزة نقاط التوقف (breakpoints) وتسهيل إدارتها. |\n| **Bootstrap / Foundation (أطر عمل CSS)** | توفر أطر العمل هذه نظام شبكي (Grid System) مبني مسبقاً ومكونات جاهزة ومتجاوبة، مما يسرع من عملية التطوير الأولية. ومع ذلك، قد يضيف استخدامها حجماً إضافياً للمشروع. |\n| **JavaScript** | يستخدم لإضافة تفاعلية متقدمة لا يمكن تحقيقها بـ CSS وحده، مثل التعامل مع إيماءات اللمس المعقدة، أو تعديل الـ DOM ديناميكياً بناءً على سلوك المستخدم. |",
        "code_examples": "### 1. نهج \"الجوال أولاً\" مع استعلامات الوسائط\n\nنبدأ بتصميم بسيط لعمود واحد للهواتف، ثم نستخدم `min-width` في استعلامات الوسائط لإضافة تخطيطات أكثر تعقيداً للشاشات الأكبر.\n\n```css\n/* الأنماط الأساسية (للجوال) */\n.container {\n  width: 100%;\n  padding: 10px;\n}\n\n.main-content, .sidebar {\n  width: 100%;\n  margin-bottom: 15px;\n}\n\n/* شاشات الأجهزة اللوحية (أكبر من 768px) */\n@media (min-width: 768px) {\n  .container {\n    display: flex;\n    justify-content: space-between;\n  }\n\n  .main-content {\n    width: 65%;\n  }\n\n  .sidebar {\n    width: 30%;\n    margin-bottom: 0;\n  }\n}\n```\n\n**الشرح:** يبدأ التخطيط بعمود واحد افتراضياً. عند عرض الصفحة على شاشة بعرض 768 بكسل أو أكثر، يتم تفعيل استعلام الوسائط لتحويل التخطيط إلى عمودين باستخدام Flexbox.\n\n### 2. شبكة مرنة باستخدام CSS Grid\n\nيمكن إنشاء شبكة تتكيف تلقائياً مع عدد العناصر المتاحة والمساحة المتوفرة.\n\n```css\n.grid-container {\n  display: grid;\n  /* إنشاء أعمدة بعرض 250px على الأقل، وتوزيع المساحة المتبقية بالتساوي */\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: 20px;\n}\n\n.grid-item {\n  background-color: #f2f2f2;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n**الشرح:** الدالة `repeat(auto-fit, minmax(250px, 1fr))` تقوم بإنشاء عدد من الأعمدة يناسب عرض الحاوية. كل عمود سيكون عرضه 250 بكسل على الأقل، وسيتمدد ليملأ المساحة الإضافية. عندما تضيق الشاشة، تنتقل العناصر تلقائياً إلى صف جديد.\n\n### 3. طباعة سائلة باستخدام `clamp()`\n\nلجعل حجم الخط يتغير بسلاسة مع عرض نافذة العرض.\n\n```css\nh1 {\n  /* الحد الأدنى لحجم الخط: 2rem (32px) */\n  /* القيمة المفضلة: 5% من عرض نافذة العرض */\n  /* الحد الأقصى لحجم الخط: 4rem (64px) */\n  font-size: clamp(2rem, 5vw, 4rem);\n}\n```\n\n**الشرح:** دالة `clamp()` تأخذ ثلاث قيم: الحد الأدنى، القيمة المفضلة، والحد الأقصى. سيبقى حجم الخط عند `2rem` على الشاشات الصغيرة جداً، وعند `4rem` على الشاشات الكبيرة جداً، وبين هذين الحدين، سيتغير حجمه بسلاسة بناءً على `5vw`.\n\n### 4. صور متجاوبة\n\nاستخدام `srcset` و `sizes` لتوفير صور مختلفة لأحجام شاشات مختلفة.\n\n```html\n<img \n  srcset=\"image-small.jpg 480w, \n          image-medium.jpg 800w, \n          image-large.jpg 1200w\"\n  sizes=\"(max-width: 600px) 480px, \n         (max-width: 1000px) 800px, \n         1200px\"\n  src=\"image-large.jpg\"\n  alt=\"وصف الصورة\">\n```\n\n**الشرح:** السمة `srcset` توفر قائمة بالصور المتاحة وعرض كل منها. السمة `sizes` تخبر المتصفح بحجم الصورة الذي سيتم عرضه عند عروض شاشة مختلفة. يقوم المتصفح بعد ذلك باختيار أنسب صورة لتحميلها، مما يوفر النطاق الترددي ويحسن الأداء.",
        "practical_tips": "1.  **ابدأ دائماً بـ HTML دلالي:** قبل كتابة أي سطر CSS، تأكد من أن بنية HTML الخاصة بك منطقية ومنظمة جيداً. المحتوى المنظم جيداً هو أساس أي تصميم متجاوب ناجح.\n\n2.  **استخدم `box-sizing: border-box`:** قم بتطبيق هذا النمط على جميع العناصر. هذا يغير نموذج الصندوق في CSS بحيث يتم تضمين `padding` و `border` في العرض والارتفاع الكلي للعنصر، مما يسهل كثيراً التعامل مع التخطيطات والشبكات.\n\n3.  **لا تعطل التكبير (Zoom):** تجنب استخدام `user-scalable=no` في وسم الميتا للـ `viewport`. القدرة على التكبير هي ميزة وصول هامة للمستخدمين الذين يعانون من ضعف في الرؤية.\n\n4.  **اختبر بدون CSS و JavaScript:** قم بتعطيل CSS و JavaScript في متصفحك مؤقتاً. هل لا يزال المحتوى قابلاً للقراءة والوصول إليه؟ هذا اختبار جيد لمبدأ التحسين التدريجي.\n\n5.  **فكر في الأداء كجزء من التصميم:** لا يقتصر التصميم المتجاوب على المظهر فقط، بل يتعلق أيضاً بالسرعة. قم بضغط الصور، وتقليل ملفات CSS و JavaScript، واستخدم تقنيات التخزين المؤقت لتحسين أوقات التحميل، خاصة على اتصالات الجوال البطيئة.\n\n6.  **استفد من وحدات `rem` للتباعد:** بالإضافة إلى حجم الخط، استخدم وحدات `rem` للـ `padding` و `margin`. هذا يسمح للتباعد بين العناصر بالتكيف بشكل متناسب إذا قام المستخدم بتغيير حجم الخط الافتراضي في متصفحه.\n\n7.  **صمم لقوالب المحتوى، وليس لأجهزة معينة:** بدلاً من التفكير \"كيف سيبدو هذا على آيفون؟\"، فكر \"كيف سيبدو هذا المكون عندما يكون لديه مساحة ضيقة مقابل مساحة واسعة؟\". هذا النهج، المدعوم باستعلامات الحاوية، يجعل مكوناتك أكثر مرونة وقوة.\n\n8.  **لا تنسَ الوضع الأفقي (Landscape Mode):** يميل المستخدمون أحياناً إلى تدوير هواتفهم. تأكد من أن تصميمك لا يزال يعمل بشكل جيد في الوضع الأفقي، وأن العناصر لا تمتد بشكل مفرط أو تصبح غير قابلة للاستخدام.",
        "common_mistakes": "| الخطأ | الحل |\n| :--- | :--- |\n| **استخدام وحدات البكسل (px) للعرض والارتفاع** | استخدم وحدات نسبية مثل النسبة المئوية (%) أو `fr` للسماح للعناصر بالتكيف مع حجم الشاشة. |\n| **تعطيل خاصية التكبير (Zoom) للمستخدم** | تجنب استخدام `user-scalable=no` في وسم الميتا للـ `viewport` لضمان إمكانية الوصول. |\n| **الاعتماد على تأثيرات التمرير (Hover) لعرض معلومات هامة** | قدم بدائل تعمل باللمس (مثل النقر) لعرض هذه المعلومات، حيث أن تأثيرات التمرير لا تعمل على شاشات اللمس. |\n| **إهمال اختبار الموقع على أجهزة حقيقية** | لا تعتمد فقط على محاكيات المتصفح. اختبر الموقع على هواتف وأجهزة لوحية حقيقية لاكتشاف المشاكل المتعلقة بالأداء والاستجابة للمس. |\n| **تحميل صور كبيرة الحجم على الأجهزة المحمولة** | استخدم تقنيات الصور المتجاوبة (`srcset`) لخدمة صور بأحجام مناسبة لكل شاشة، واستخدم صيغ حديثة مثل WebP. |\n| **تحديد نقاط التوقف (Breakpoints) بناءً على أجهزة معينة** | حدد نقاط التوقف بناءً على المحتوى نفسه. عندما يبدأ التصميم في \"التكسر\"، أضف نقطة توقف. |\n| **نسيان وسم الميتا للـ `viewport`** | تأكد من تضمين `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">` في رأس الصفحة لضمان العرض الصحيح على الجوال. |\n| **كتابة استعلامات وسائط معقدة ومتشعبة** | حافظ على بساطة استعلامات الوسائط. اتبع نهج \"الجوال أولاً\" واستخدم `min-width` للتوسع تدريجياً. |",
        "checklist": "- [ ] هل تم تضمين وسم الميتا للـ `viewport` بشكل صحيح في `<head>`؟\n- [ ] هل التصميم يتبع نهج \"الجوال أولاً\"؟\n- [ ] هل تم استخدام وحدات نسبية (%, vw, fr) للتخطيطات المرنة؟\n- [ ] هل نقاط التوقف (Breakpoints) محددة بناءً على المحتوى وليس أجهزة معينة؟\n- [ ] هل حجم الخطوط قابل للقراءة ويتكيف مع الشاشات المختلفة (باستخدام `rem` أو `clamp()`)؟\n- [ ] هل العناصر القابلة للنقر (الأزرار، الروابط) كبيرة بما يكفي وسهلة الاستخدام على شاشات اللمس؟\n- [ ] هل الصور مُحسَّنة ويتم تحميل الحجم المناسب لكل شاشة؟\n- [ ] هل الموقع يعمل بشكل جيد في الوضعين الرأسي والأفقي؟\n- [ ] هل يمكن للمستخدمين تكبير وتصغير الصفحة؟\n- [ ] هل تم اختبار الموقع على متصفحات وأجهزة حقيقية مختلفة؟\n- [ ] هل المحتوى لا يزال قابلاً للوصول عند تعطيل CSS أو JavaScript؟\n- [ ] هل أداء الموقع سريع ومُحسَّن، خاصة على اتصالات الجوال؟",
        "sources": "*   [MDN Web Docs: Responsive web design](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)\n*   [Google for Developers: Responsive web design basics](https://web.dev/responsive-web-design-basics/)\n*   [W3Schools: Responsive Web Design](https://www.w3schools.com/css/css_rwd_intro.asp)\n*   [Smashing Magazine: Modern Fluid Typography Using CSS Clamp](https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/)\n*   [CSS-Tricks: A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\n*   [CSS-Tricks: A Complete Guide to Grid](https://css-tricks.com/snippets/css/complete-guide-grid/)\n*   [MDN Web Docs: Container queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries)"
      },
      "error": ""
    },
    {
      "input": "معايير أمان المواقع: OWASP Top 10, XSS Prevention, SQL Injection Prevention, CSRF Protection, HTTPS/TLS, Security Headers (CSP, HSTS), JWT Security Best Practices, Input Validation, Rate Limiting",
      "output": {
        "topic_title": "معايير أمان المواقع: دليل شامل للحماية من التهديدات الرقمية",
        "introduction": "يمثل أمان المواقع الإلكترونية حجر الزاوية في بناء الثقة الرقمية وحماية البيانات في العصر الحديث. مع تزايد الاعتماد على الخدمات الرقمية، أصبحت المواقع الإلكترونية هدفًا رئيسيًا للمهاجمين الذين يسعون لاستغلال الثغرات الأمنية للوصول غير المصرح به إلى البيانات الحساسة، أو تعطيل الخدمات، أو إلحاق الضرر بالسمعة. إن فهم وتطبيق معايير الأمان العالمية لم يعد خيارًا، بل ضرورة ملحة لضمان استمرارية الأعمال وحماية المستخدمين. يهدف هذا التقرير إلى تقديم نظرة شاملة وعملية على أهم معايير أمان المواقع، بدءًا من تحديد المخاطر الأكثر شيوعًا وصولًا إلى استعراض أفضل الممارسات والتقنيات اللازمة لبناء تطبيقات ويب آمنة ومحصنة ضد التهديدات المتطورة.",
        "key_concepts": "لفهم أمان المواقع بعمق، لا بد من الإلمام ببعض المفاهيم والمصطلحات الأساسية التي تشكل لغة هذا المجال:\n\n*   **OWASP Top 10:** هي قائمة مرجعية قياسية تصدرها \"مشروع أمان تطبيقات الويب المفتوح\" (OWASP)، وتحدد أخطر 10 تهديدات أمنية تواجه تطبيقات الويب. تعتبر هذه القائمة نقطة انطلاق أساسية للمطورين والمختصين لفهم وتأمين تطبيقاتهم.\n*   **Cross-Site Scripting (XSS):** هجوم يتم فيه حقن سكربتات خبيثة (عادة JavaScript) في صفحات الويب التي يشاهدها المستخدمون الآخرون. يمكن أن يؤدي هذا الهجوم إلى سرقة جلسات المستخدمين، أو تشويه المواقع، أو إعادة توجيه المستخدمين إلى مواقع ضارة.\n*   **SQL Injection (SQLi):** ثغرة أمنية تسمح للمهاجم بالتدخل في الاستعلامات التي يجريها التطبيق على قاعدة بياناته. يمكن للمهاجم استخدام هذه الثغرة للوصول إلى بيانات حساسة أو تعديلها أو حذفها.\n*   **Cross-Site Request Forgery (CSRF):** هجوم يجبر المستخدم النهائي على تنفيذ إجراءات غير مرغوب فيها على تطبيق ويب يكون لديه صلاحية الوصول إليه. ينجح هذا الهجوم لأن التطبيق يثق في الطلب القادم من متصفح المستخدم المصادق عليه.\n*   **HTTPS/TLS:** بروتوكول (HTTPS) هو النسخة الآمنة من HTTP، حيث يتم تشفير الاتصال بين متصفح المستخدم والموقع الإلكتروني باستخدام بروتوكول أمان طبقة النقل (TLS). هذا يمنع التنصت على البيانات الحساسة مثل كلمات المرور وتفاصيل بطاقات الائتمان.\n*   **Security Headers:** هي رؤوس استجابة HTTP يرسلها الخادم إلى المتصفح لفرض سياسات أمنية معينة. من الأمثلة عليها:\n    *   **Content Security Policy (CSP):** تساعد في منع هجمات XSS عن طريق تحديد مصادر المحتوى الموثوقة التي يمكن للمتصفح تحميلها.\n    *   **HTTP Strict Transport Security (HSTS):** تفرض على المتصفحات استخدام اتصالات HTTPS الآمنة دائمًا مع الموقع.\n*   **JWT (JSON Web Token) Security:** مجموعة من أفضل الممارسات لتأمين استخدام توكنات JWT، وهي معيار مفتوح لإنشاء توكنات وصول تتيح تبادل المعلومات بشكل آمن بين طرفين.\n*   **Input Validation:** عملية التحقق من أن جميع المدخلات التي يقدمها المستخدم تتوافق مع التنسيق والنوع والقيم المتوقعة قبل معالجتها. تعتبر خط الدفاع الأول ضد العديد من الهجمات.\n*   **Rate Limiting:** تقنية تستخدم للتحكم في عدد الطلبات التي يمكن للمستخدم إرسالها إلى الخادم في فترة زمنية معينة. تساعد في الحماية من هجمات القوة الغاشمة (Brute-force) وهجمات الحرمان من الخدمة (DoS).",
        "best_practices": "لتحقيق مستوى عالٍ من الأمان، يجب تبني مجموعة من أفضل الممارسات التي تغطي مختلف جوانب تطوير وتشغيل المواقع الإلكترونية.\n\n### 1. اتباع إرشادات OWASP Top 10\n\n*   **المراجعة الدورية:** يجب على فرق التطوير مراجعة قائمة OWASP Top 10 بانتظام وفهم كيفية تأثير هذه المخاطر على تطبيقاتهم.\n*   **التدريب والتوعية:** تدريب المطورين والمختصين في مجال ضمان الجودة على هذه المخاطر وكيفية اكتشافها ومعالجتها.\n*   **التكامل مع دورة حياة تطوير البرمجيات (SDLC):** دمج متطلبات الأمان المستمدة من OWASP Top 10 في جميع مراحل تطوير البرمجيات، من التصميم إلى النشر والصيانة.\n\n### 2. الوقاية من هجمات XSS\n\n*   **ترميز المخرجات (Output Encoding):** هي الاستراتيجية الأكثر فعالية. قبل عرض أي بيانات قادمة من المستخدم في صفحة HTML، يجب ترميزها لتحويل الأحرف الخاصة (مثل `<`, `>`, `\"`, `\"`, `&`) إلى ما يعادلها في HTML (مثل `&lt;`, `&gt;`, `&quot;`, `&#39;`, `&amp;`). هذا يضمن أن المتصفح يعرض البيانات كنص فقط وليس ككود قابل للتنفيذ.\n*   **التحقق من صحة المدخلات (Input Validation):** رفض أي مدخلات تحتوي على علامات HTML أو سكربتات إذا لم تكن ضرورية لوظيفة التطبيق.\n*   **استخدام سياسة أمان المحتوى (CSP):** تطبيق رأس `Content-Security-Policy` للحد من المصادر التي يمكن للمتصفح تحميل السكربتات منها، مما يقلل من تأثير أي هجوم XSS قد يحدث.\n\n### 3. الوقاية من هجمات حقن SQL\n\n*   **استخدام الاستعلامات المعدة مسبقًا (Prepared Statements/Parameterized Queries):** هذه هي الطريقة الأكثر أمانًا. يتم إرسال قالب الاستعلام إلى قاعدة البيانات بشكل منفصل عن البيانات (المعلمات). هذا يضمن أن قاعدة البيانات لا تخلط بين الكود والبيانات، مما يمنع المهاجم من تغيير منطق الاستعلام.\n*   **تجنب بناء الاستعلامات الديناميكية:** لا تقم ببناء استعلامات SQL عن طريق ربط السلاسل النصية مباشرة من مدخلات المستخدم.\n*   **مبدأ الامتياز الأقل (Principle of Least Privilege):** منح حساب قاعدة البيانات الذي يستخدمه التطبيق أقل الصلاحيات الممكنة التي يحتاجها لأداء وظائفه فقط. على سبيل المثال، لا تمنحه صلاحيات إدارية مثل `DROP TABLE`.\n\n### 4. الحماية من هجمات CSRF\n\n*   **استخدام توكنات مكافحة CSRF (Anti-CSRF Tokens):** الطريقة الأكثر شيوعًا. يقوم الخادم بإنشاء توكن فريد وسري لكل جلسة مستخدم وإدراجه في النماذج كحقل مخفي. عند إرسال النموذج، يتحقق الخادم من أن التوكن المرسل يطابق التوكن المخزن لديه. بما أن المهاجم لا يعرف هذا التوكن، فإنه لا يستطيع إنشاء طلب صالح.\n*   **استخدام خاصية SameSite للـ Cookies:** يمكن تعيين خاصية `SameSite` لملفات تعريف الارتباط (الكوكيز) إلى `Strict` أو `Lax`. هذا يمنع المتصفح من إرسال الكوكيز مع الطلبات القادمة من مواقع خارجية، مما يحبط هجمات CSRF.\n*   **التحقق من رأس Referer:** يمكن التحقق من رأس `Referer` في طلب HTTP للتأكد من أن الطلب قادم من صفحات الموقع نفسه. ومع ذلك، هذه الطريقة ليست مضمونة دائمًا ويمكن تجاوزها.\n\n### 5. تطبيق HTTPS/TLS\n\n*   **الحصول على شهادة SSL/TLS:** قم بشراء شهادة SSL/TLS من مرجع مصدق موثوق (Certificate Authority) أو استخدم شهادات مجانية مثل التي توفرها Let's Encrypt.\n*   **تكوين الخادم لـ HTTPS:** قم بتكوين خادم الويب الخاص بك لاستخدام الشهادة وتفعيل HTTPS.\n*   **إعادة توجيه كل حركة المرور إلى HTTPS:** تأكد من أن جميع طلبات HTTP يتم إعادة توجيهها بشكل دائم (301 redirect) إلى HTTPS لضمان أن جميع الاتصالات مشفرة.\n*   **تفعيل HSTS:** استخدم رأس `Strict-Transport-Security` لإجبار المتصفحات على التواصل مع موقعك باستخدام HTTPS فقط في المستقبل.\n\n### 6. استخدام رؤوس الأمان (Security Headers)\n\n*   **Content Security Policy (CSP):** قم بتعريف سياسة صارمة تحدد المصادر المسموح بها للسكربتات، والأنماط، والصور، وغيرها. هذا يقلل بشكل كبير من مخاطر XSS.\n*   **HTTP Strict Transport Security (HSTS):** كما ذكرنا، يفرض استخدام HTTPS.\n*   **X-Frame-Options:** يمنع تحميل موقعك داخل `<iframe>` على مواقع أخرى، مما يحميك من هجمات Clickjacking.\n*   **X-Content-Type-Options:** يمنع المتصفح من محاولة تخمين نوع المحتوى (MIME sniffing)، مما يقلل من مخاطر أمنية معينة.\n\n### 7. أفضل ممارسات أمان JWT\n\n*   **استخدام خوارزميات توقيع قوية:** استخدم خوارزميات غير متماثلة (مثل RS256) بدلاً من الخوارزميات المتماثلة (مثل HS256) إذا كان ذلك ممكنًا، خاصة في الأنظمة الموزعة.\n*   **لا تقم بتخزين معلومات حساسة في الحمولة (Payload):** حمولة JWT يمكن فك ترميزها بسهولة (Base64 decoded)، لذا لا تضع فيها بيانات حساسة مثل كلمات المرور.\n*   **تعيين تاريخ انتهاء صلاحية قصير (exp):** اجعل عمر التوكن قصيرًا قدر الإمكان لتقليل الضرر في حال تسربه.\n*   **التحقق من التوقيع دائمًا:** عند استلام JWT، تحقق دائمًا من صحة التوقيع قبل الوثوق بمحتوياته.\n\n### 8. التحقق من صحة المدخلات (Input Validation)\n\n*   **التحقق من جانب الخادم (Server-Side Validation):** لا تعتمد أبدًا على التحقق من جانب العميل (Client-Side) فقط، حيث يمكن تجاوزه بسهولة. قم دائمًا بإعادة التحقق من جميع البيانات على الخادم.\n*   **استخدام القائمة البيضاء (Whitelisting):** بدلاً من محاولة حظر المدخلات السيئة (Blacklisting)، قم بتعريف وقبول المدخلات الجيدة المعروفة فقط. على سبيل المثال، إذا كان الحقل يتوقع رمزًا بريديًا من 5 أرقام، فارفض أي شيء آخر.\n*   **التحقق من النوع، والطول، والتنسيق، والنطاق.**\n\n### 9. تطبيق تحديد المعدل (Rate Limiting)\n\n*   **حماية نقاط النهاية الحساسة:** طبق تحديد المعدل على وظائف تسجيل الدخول، وإعادة تعيين كلمة المرور، وأي واجهات برمجة تطبيقات (APIs) تستهلك موارد كبيرة.\n*   **التحديد بناءً على IP أو حساب المستخدم:** يمكنك تطبيق التحديد بناءً على عنوان IP للمستخدم، أو حسابه، أو كليهما.\n*   **إرجاع رسائل خطأ واضحة:** عند تجاوز الحد، أرجع استجابة HTTP `429 Too Many Requests` لإعلام العميل بأنه يجب أن يبطئ.",
        "tools_technologies": "تتوفر مجموعة واسعة من الأدوات والتقنيات التي تساعد في تأمين المواقع الإلكترونية، بدءًا من الفحص الآلي للثغرات وصولًا إلى جدران الحماية المتقدمة.\n\n### أدوات فحص الثغرات (Vulnerability Scanners)\n\nهذه الأدوات تقوم بفحص تطبيقات الويب تلقائيًا بحثًا عن الثغرات الأمنية الشائعة.\n\n*   **OWASP ZAP (Zed Attack Proxy):** أداة مجانية ومفتوحة المصدر وقوية جدًا لاختبار الاختراق. يمكن استخدامها كوكيل (proxy) لاعتراض وتحليل حركة المرور بين المتصفح والتطبيق، بالإضافة إلى فحص آلي للثغرات.\n*   **Burp Suite:** أداة شائعة جدًا بين مختبري الاختراق. تأتي في نسخة مجتمعية مجانية ونسخة احترافية مدفوعة توفر ميزات فحص آلية متقدمة.\n*   **Nessus:** أداة فحص شاملة لا تقتصر على تطبيقات الويب فقط، بل تفحص الشبكات وأنظمة التشغيل بحثًا عن آلاف الثغرات المعروفة.\n*   **Acunetix & Invicti:** أدوات تجارية رائدة في فحص أمان تطبيقات الويب، تشتهر بدقتها وسهولة استخدامها وقدرتها على اكتشاف مجموعة واسعة من الثغرات.\n\n### جدران حماية تطبيقات الويب (Web Application Firewalls - WAF)\n\nيعمل WAF كدرع بين المستخدمين وتطبيق الويب، حيث يقوم بتحليل طلبات HTTP الواردة وحظر الطلبات الخبيثة التي تطابق أنماط هجوم معروفة (مثل حقن SQL و XSS).\n\n*   **ModSecurity:** أشهر WAF مفتوح المصدر. يمكن دمجه مع خوادم الويب مثل Apache و Nginx.\n*   **Cloudflare WAF:** خدمة سحابية شائعة توفر حماية WAF كجزء من شبكة توصيل المحتوى (CDN) الخاصة بها. تتميز بسهولة الإعداد والقدرة على الحماية من هجمات DDoS.\n*   **AWS WAF & Azure WAF:** خدمات WAF سحابية متكاملة توفرها Amazon Web Services و Microsoft Azure لحماية التطبيقات المستضافة على منصاتهما.\n\n### تقنيات من جانب الخادم (Server-Side Technologies)\n\n*   **لغات البرمجة وأطر العمل الآمنة:** استخدام أطر عمل حديثة (مثل Django, Ruby on Rails, Laravel, ASP.NET Core) يساعد كثيرًا، حيث تأتي مع حماية مدمجة ضد العديد من الهجمات الشائعة مثل CSRF و XSS و SQL Injection.\n*   **إدارة كلمات المرور:** استخدام مكتبات لتجزئة كلمات المرور (Password Hashing) مثل `bcrypt` أو `Argon2` بدلاً من تخزينها كنص عادي أو باستخدام خوارزميات تجزئة ضعيفة مثل MD5.\n\n### تقنيات من جانب العميل (Client-Side Technologies)\n\n*   **أطر عمل JavaScript الحديثة:** أطر العمل مثل React, Angular, و Vue.js تقوم بترميز المخرجات افتراضيًا، مما يقلل من مخاطر XSS بشكل كبير مقارنة بالتعامل المباشر مع DOM.\n*   **مكتبات التعقيم (Sanitization Libraries):** مكتبات مثل `DOMPurify` يمكن استخدامها لتنظيف أي محتوى HTML قادم من المستخدم قبل إضافته إلى الصفحة، مما يسمح ببعض التنسيق مع إزالة العناصر الخطرة.",
        "code_examples": "توضح هذه الأمثلة كيفية تطبيق بعض الممارسات الأمنية في لغات برمجة شائعة.\n\n### مثال 1: منع حقن SQL في PHP باستخدام PDO\n\nبدلاً من إدخال متغيرات المستخدم مباشرة في الاستعلام، نستخدم الاستعلامات المعدة مسبقًا. هذا يفصل الكود عن البيانات.\n\n**الطريقة غير الآمنة (لا تستخدمها):**\n```php\n<?php\n$pdo = new PDO('mysql:host=localhost;dbname=test', 'user', 'pass');\n$name = $_GET['name'];\n$stmt = $pdo->query(\"SELECT * FROM users WHERE name = '\" . $name . \"'\"); // ثغرة حقن SQL\n$user = $stmt->fetch();\n?>\n```\n\n**الطريقة الآمنة (استخدام Prepared Statements):**\n```php\n<?php\n$pdo = new PDO('mysql:host=localhost;dbname=test', 'user', 'pass');\n$name = $_GET['name'];\n\n// 1. قم بإعداد الاستعلام مع علامة استفهام كعنصر نائب\n$stmt = $pdo->prepare('SELECT * FROM users WHERE name = ?');\n\n// 2. قم بتنفيذ الاستعلام مع تمرير بيانات المستخدم كمعلمة\n$stmt->execute([$name]);\n\n// 3. احصل على النتائج بأمان\n$user = $stmt->fetch();\n?>\n```\n\n### مثال 2: منع XSS في PHP\n\nعند عرض أي بيانات قادمة من المستخدم، استخدم `htmlspecialchars()` لترميز الأحرف الخاصة.\n\n```php\n<?php\n// المدخل يأتي من المستخدم (مثل حقل تعليق)\n$comment = '<script>alert(\"XSS Attack!\");</script>';\n\n// عرض التعليق بأمان عن طريق ترميزه\n// المتصفح سيعرض السكربت كنص ولن يقوم بتنفيذه\necho htmlspecialchars($comment, ENT_QUOTES, 'UTF-8');\n?>\n```\n\n### مثال 3: منع CSRF في تطبيق ويب (مثال مبسط بلغة Python/Flask)\n\nنستخدم توكن CSRF لحماية النماذج.\n\n```python\nfrom flask import Flask, render_template, request, session, abort\nimport os\n\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        # 3. تحقق من أن التوكن المرسل يطابق التوكن في الجلسة\n        if 'csrf_token' not in session or session['csrf_token'] != request.form.get('csrf_token'):\n            abort(403) # Forbidden\n        \n        # ... قم بمعالجة التحويل المالي هنا ...\n        return 'Transfer successful!'\n    else:\n        # 1. أنشئ توكن CSRF جديدًا وخزنه في الجلسة\n        if 'csrf_token' not in session:\n            session['csrf_token'] = os.urandom(16).hex()\n        \n        # 2. مرر التوكن إلى القالب ليتم إدراجه في النموذج\n        return render_template('transfer_form.html', csrf_token=session['csrf_token'])\n\n# transfer_form.html (قالب HTML)\n# <form method=\"post\">\n#   <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token }}\">\n#   <input type=\"text\" name=\"amount\" placeholder=\"Amount\">\n#   <input type=\"text\" name=\"to_account\" placeholder=\"To Account\">\n#   <button type=\"submit\">Transfer</button>\n# </form>\n```",
        "practical_tips": "1.  **لا تثق أبدًا بمدخلات المستخدم:** هذه هي القاعدة الذهبية في أمان الويب. تحقق دائمًا من صحة جميع البيانات القادمة من العميل وقم بترميزها عند عرضها.\n2.  **حافظ على تحديث كل شيء:** قم بتحديث لغات البرمجة، وأطر العمل، والمكتبات، وأنظمة إدارة المحتوى (CMS)، والخوادم بانتظام. غالبًا ما تحتوي التحديثات على إصلاحات أمنية حيوية.\n3.  **استخدم HTTPS في كل مكان:** لا يوجد سبب اليوم لعدم استخدام HTTPS. التشفير يحمي بيانات المستخدمين ويزيد من ثقتهم في موقعك.\n4.  **طبق مبدأ الامتياز الأقل:** سواء كان ذلك لحسابات قاعدة البيانات أو حسابات المستخدمين في التطبيق، امنح كل حساب أقل الصلاحيات التي يحتاجها لأداء وظيفته فقط.\n5.  **اجعل رسائل الخطأ عامة:** لا تكشف عن تفاصيل تقنية حساسة (مثل استعلامات SQL أو مسارات الملفات على الخادم) في رسائل الخطأ التي تظهر للمستخدمين. سجل التفاصيل في ملفات سجل الخادم للمطورين فقط.\n6.  **استخدم أدوات الفحص الآلي بانتظام:** قم بدمج أدوات مثل OWASP ZAP في عملية التطوير والنشر لاكتشاف الثغرات بشكل استباقي.\n7.  **قم بتأمين ملفات تعريف الارتباط (Cookies):** استخدم السمات `Secure` (لإرسالها عبر HTTPS فقط) و `HttpOnly` (لمنع الوصول إليها من خلال JavaScript) و `SameSite` (للحماية من CSRF).\n8.  **نفذ مراجعات أمنية للكود (Code Reviews):** اجعل مراجعة الأمان جزءًا من عملية مراجعة الكود. يمكن لزميل آخر في الفريق اكتشاف ثغرات قد لا تلاحظها.\n9.  **ضع خطة للاستجابة للحوادث:** ماذا ستفعل إذا تم اختراق موقعك؟ وجود خطة واضحة مسبقًا يمكن أن يقلل بشكل كبير من الأضرار ووقت التوقف عن العمل.\n10. **تعلم من أخطاء الآخرين:** تابع أخبار الثغرات الأمنية والاختراقات لفهم أساليب الهجوم الجديدة وكيفية الحماية منها.",
        "common_mistakes": "1.  **الثقة العمياء في بيانات العميل:** الخطأ الأكثر شيوعًا هو افتراض أن البيانات القادمة من متصفح المستخدم (سواء كانت في نماذج، أو عناوين URL، أو كوكيز) آمنة. هذا يؤدي مباشرة إلى ثغرات مثل XSS و SQL Injection.\n    *   **الحل:** التعامل مع جميع مدخلات المستخدم على أنها غير موثوق بها والتحقق منها وتعقيمها دائمًا على الخادم.\n2.  **عدم ترميز المخرجات (Output Encoding):** الفشل في ترميز البيانات قبل عرضها في صفحة HTML. يعتقد بعض المطورين أن التحقق من المدخلات كافٍ، ولكنه ليس كذلك.\n    *   **الحل:** استخدام دوال مثل `htmlspecialchars()` في PHP أو ما يعادلها في اللغات الأخرى دائمًا عند عرض بيانات المستخدم.\n3.  **بناء استعلامات SQL يدويًا:** استخدام ربط السلاسل النصية (String Concatenation) لإنشاء استعلامات SQL مع مدخلات المستخدم بدلاً من استخدام الاستعلامات المعدة مسبقًا.\n    *   **الحل:** استخدام الاستعلامات المعدة مسبقًا (Prepared Statements) دائمًا، فهي مصممة خصيصًا لمنع حقن SQL.\n4.  **تخزين كلمات المرور بشكل غير آمن:** تخزين كلمات المرور كنص عادي أو استخدام خوارزميات تجزئة قديمة وضعيفة مثل MD5 أو SHA1.\n    *   **الحل:** استخدام خوارزميات تجزئة قوية ومخصصة لكلمات المرور مثل `Bcrypt` أو `Argon2`.\n5.  **إهمال تحديث المكتبات وأطر العمل:** استخدام إصدارات قديمة من البرامج تحتوي على ثغرات أمنية معروفة وموثقة.\n    *   **الحل:** استخدام أدوات لإدارة التبعيات (مثل `npm`, `pip`, `composer`) وفحصها بانتظام بحثًا عن الثغرات وتحديثها باستمرار.\n6.  **عرض رسائل خطأ مفصلة في بيئة الإنتاج:** كشف تفاصيل تقنية حساسة عن الخادم أو قاعدة البيانات في رسائل الخطأ التي تظهر للمستخدمين، مما يساعد المهاجمين.\n    *   **الحل:** تكوين الخادم لعرض رسائل خطأ عامة للمستخدمين وتسجيل التفاصيل الكاملة في ملفات السجل الخاصة بالخادم فقط.\n7.  **عدم تطبيق رؤوس الأمان (Security Headers):** الفشل في استخدام رؤوس HTTP الأمنية مثل CSP و HSTS و X-Frame-Options، مما يترك الموقع عرضة لهجمات معروفة.\n    *   **الحل:** تكوين خادم الويب لإضافة هذه الرؤوس إلى جميع الاستجابات.",
        "checklist": "*   [ ] هل يتم التحقق من صحة جميع مدخلات المستخدم على الخادم؟\n*   [ ] هل يتم ترميز جميع المخرجات المعروضة في HTML لمنع XSS؟\n*   [ ] هل يتم استخدام الاستعلامات المعدة مسبقًا (Parameterized Queries) لجميع تفاعلات قاعدة البيانات؟\n*   [ ] هل يتم استخدام توكنات Anti-CSRF لحماية جميع الطلبات التي تغير الحالة (POST, PUT, DELETE)؟\n*   [ ] هل الموقع يعمل بالكامل عبر HTTPS؟\n*   [ ] هل تم تفعيل رأس HSTS؟\n*   [ ] هل تم تطبيق سياسة أمان محتوى (CSP) صارمة؟\n*   [ ] هل تم تعيين رؤوس الأمان الأخرى مثل `X-Frame-Options` و `X-Content-Type-Options`؟\n*   [ ] هل يتم تجزئة كلمات المرور باستخدام خوارزمية قوية (مثل Bcrypt)؟\n*   [ ] هل صلاحيات حساب قاعدة البيانات محدودة بالحد الأدنى المطلوب؟\n*   [ ] هل يتم تحديث جميع المكتبات وأطر العمل والمنصات بانتظام؟\n*   [ ] هل تم تطبيق تحديد المعدل (Rate Limiting) على نقاط النهاية الحساسة؟\n*   [ ] هل رسائل الخطأ في بيئة الإنتاج عامة ولا تكشف عن تفاصيل حساسة؟\n*   [ ] هل تم تأمين ملفات تعريف الارتباط باستخدام سمات `Secure` و `HttpOnly` و `SameSite`؟",
        "sources": "*   [OWASP Top Ten Project](https://owasp.org/www-project-top-ten/)\n*   [MDN Web Docs: Website security](https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps/Website_security)\n*   [OWASP Cheat Sheet Series: Cross-Site Scripting Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n*   [OWASP Cheat Sheet Series: SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n*   [OWASP Cheat Sheet Series: Cross-Site Request Forgery Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n*   [Google Developers: Web Fundamentals - Security](https://developers.google.com/web/fundamentals/security)\n*   [Cloudflare: What is Website Security?](https://www.cloudflare.com/learning/security/what-is-website-security/)"
      },
      "error": ""
    },
    {
      "input": "هيكلة REST API الاحترافية: RESTful Design Principles, API Versioning, HTTP Status Codes, Error Handling, Request/Response Format, API Documentation (OpenAPI/Swagger), Authentication Methods, CORS",
      "output": {
        "topic_title": "هيكلة REST API الاحترافية",
        "introduction": "تُعتبر واجهات برمجة التطبيقات (APIs) القائمة على معمارية REST (Representational State Transfer) حجر الزاوية في تطوير الويب الحديث. فهي تُمكّن الأنظمة المختلفة من التواصل وتبادل البيانات بشكل آمن وفعّال عبر الإنترنت. إن تصميم واجهة برمجة تطبيقات RESTful احترافية ليس مجرد ضرورة تقنية، بل هو استثمار استراتيجي يضمن قابلية التوسع والصيانة السهلة للتطبيقات، ويُحسّن تجربة المطورين الذين يستخدمونها. من خلال الالتزام بمبادئ التصميم الراسخة مثل الواجهة الموحدة، وانعدام الحالة (Statelessness)، واستخدام بروتوكولات الويب القياسية، يمكن بناء واجهات برمجية قوية ومرنة وقادرة على التطور مع متطلبات العمل المتغيرة.",
        "key_concepts": "- **المورد (Resource):** هو أي كائن أو بيانات أو خدمة يمكن الوصول إليها من قبل العميل. يمثل كل مورد بمعرف مورد موحد (URI) فريد.\n- **معرف المورد الموحد (URI):** هو معرف فريد يحدد المورد. على سبيل المثال، `https://api.example.com/users/123`.\n- **تمثيل المورد (Resource Representation):** هو كيفية تشفير المورد ونقله عبر بروتوكول HTTP بتنسيق معين، مثل JSON أو XML.\n- **الواجهة الموحدة (Uniform Interface):** هي الطريقة التي تحقق بها واجهات برمجة تطبيقات RESTful اقترانًا فضفاضًا بين تطبيقات العميل والخادم. تتضمن استخدام أفعال HTTP القياسية لتنفيذ العمليات على الموارد.\n- **انعدام الحالة (Stateless):** يعني أن كل طلب HTTP مستقل وقد يحدث بأي ترتيب. لا يتم تخزين أي معلومات حالة عابرة بين الطلبات.\n- **الوسائط التشعبية كمحرك لحالة التطبيق (HATEOAS):** يمكن تشغيل واجهات برمجة تطبيقات REST بواسطة ارتباطات الوسائط التشعبية المضمنة في كل تمثيل للموارد.",
        "best_practices": "- **استخدم الأسماء لل موارد وليس الأفعال:** يجب أن تمثل URIs الموارد، لذا استخدم الأسماء (عادة بصيغة الجمع) بدلاً من الأفعال. على سبيلG, `POST` للإنشاء، `PUT` للتحديث الكامل، `PATCH` للتحديث الجزئي، و `DELETE` للحذف.\n- **انعدام الحالة (Statelessness):** يجب أن يحتوي كل طلب على جميع المعلومات التي يحتاجها الخادم لفهمه ومعالجته، دون الاعتماد على أي سياق سابق للعميل.\n- **استخدم رموز حالة HTTP القياسية:** استخدم رموز الحالة بشكل متسق للإشارة إلى نجاح أو فشل الطلب. على سبيل المثال، `200 OK`، `201 Created`، `400 Bad Request`، `404 Not Found`، `500 Internal Server Error`.\n- **إصدار API:** قم بإصدار واجهة برمجة التطبيقات الخاصة بك للحفاظ على التوافق مع الإصدارات السابقة. يمكن أن يتم ذلك من خلال URI (على سبيل المثال، `/v1/users`)، أو من خلال ترويسة مخصصة (على سبيل المثال، `X-API-Version: 1`).\n- **الترقيم والفرز والتصفية:** قم بتوفير آليات للترقيم (Pagination) والفرز (Sorting) والتصفية (Filtering) للتحكم في حجم الاستجابة.\n- **الأمان:** استخدم HTTPS لتشفير الاتصال. استخدم آليات مصادقة قوية مثل OAuth 2.0.\n- **التوثيق:** قم بتوثيق واجهة برمجة التطبيقات الخاصة بك باستخدام معايير مثل OpenAPI (المعروفة سابقًا باسم Swagger) لتسهيل فهمها واستخدامها من قبل المطورين.",
        "tools_technologies": "- **Postman:** أداة شائعة لاختبار وتصحيح واجهات برمجة التطبيقات. تسمح للمطورين بإرسال طلبات HTTP بسهولة وفحص الاستجابات.\n- **Swagger/OpenAPI:** مواصفات لتوثيق واجهات برمجة تطبيقات RESTful. توفر طريقة موحدة لوصف نقاط النهاية (Endpoints) والعمليات والمعلمات والاستجابات.\n- **Insomnia:** بديل لـ Postman، وهو عميل REST قوي ومفتوح المصدر لتصحيح الأخطاء واختبار واجهات برمجة التطبيقات.\n- **JWT (JSON Web Tokens):** معيار مفتوح لإنشاء رموز وصول (access tokens) قائمة على JSON. تستخدم بشكل شائع لتأمين واجهات برمجة التطبيقات.\n- **OAuth 2.0:** إطار عمل للتفويض يسمح للتطبيقات بالحصول على وصول محدود إلى حسابات المستخدمين على خدمة HTTP.",
        "code_examples": "### مثال على طلب GET بسيط\n\n```bash\nGET /users/123\n```\n\n**الاستجابة:**\n\n```json\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john.doe@example.com\"\n}\n```\n\n### مثال على طلب POST لإنشاء مورد\n\n```bash\nPOST /users\nContent-Type: application/json\n\n{\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane.doe@example.com\"\n}\n```\n\n**الاستجابة:**\n\n```json\n{\n  \"id\": 124,\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane.doe@example.com\"\n}\n```\n\n### مثال على معالجة الأخطاء\n\n```bash\nGET /users/999\n```\n\n**الاستجابة:**\n\n```json\n{\n  \"error\": {\n    \"status\": 404,\n    \"message\": \"User not found\"\n  }\n}\n```",
        "practical_tips": "1.  **ابدأ بتصميم العقد أولاً (Contract-First):** قبل كتابة أي كود، قم بتصميم وتوثيق واجهة برمجة التطبيقات الخاصة بك باستخدام OpenAPI. هذا يضمن أن جميع أصحاب المصلحة متفقون على التصميم.\n2.  **اجعل رسائل الخطأ مفيدة:** لا تقم فقط بإرجاع رمز حالة الخطأ. قم بتضمين رسالة خطأ واضحة وموجزة، وربما معرف فريد للخطأ لتسهيل التصحيح.\n3.  **استخدم التخزين المؤقت (Caching) لتحسين الأداء:** استخدم ترويسات HTTP مثل `ETag` و `Cache-Control` لتمكين التخزين المؤقت من جانب العميل وتقليل الحمل على الخادم.\n4.  **فكر في الأمان منذ البداية:** لا تترك الأمان كفكرة لاحقة. قم بتطبيق HTTPS والمصادقة والترخيص المناسبين منذ بداية المشروع.\n5.  **حافظ على بساطة الأمور:** تجنب الإفراط في هندسة واجهة برمجة التطبيقات الخاصة بك. ابدأ بتصميم بسيط وقم بتطويره حسب الحاجة.",
        "common_mistakes": "- **تجاهل معايير HTTP:** عدم استخدام أفعال HTTP ورموز الحالة بشكل صحيح.\n- **URIs معقدة وغير متسقة:** استخدام URIs طويلة ومعقدة وصعبة الفهم.\n- **استجابات غير متسقة:** إرجاع تنسيقات بيانات مختلفة لنفس النوع من الموارد.\n- **عدم وجود إصدار:** إجراء تغييرات على واجهة برمجة التطبيقات دون إصدارها، مما يؤدي إلى كسر تطبيقات العميل.\n- **ضعف معالجة الأخطاء:** إرجاع رسائل خطأ غامضة أو غير مفيدة.",
        "checklist": "- هل تستخدم الأسماء (صيغة الجمع) للموارد في URIs؟\n- هل تستخدم أفعال HTTP بشكل صحيح (GET, POST, PUT, PATCH, DELETE)؟\n- هل واجهة برمجة التطبيقات الخاصة بك عديمة الحالة (Stateless)؟\n- هل تستخدم رموز حالة HTTP القياسية بشكل متسق؟\n- هل لديك استراتيجية لإصدار واجهة برمجة التطبيقات؟\n- هل تدعم الترقيم والفرز والتصفية؟\n- هل تستخدم HTTPS لتأمين الاتصالات؟\n- هل تستخدم آلية مصادقة قوية؟\n- هل واجهة برمجة التطبيقات الخاصة بك موثقة جيدًا باستخدام OpenAPI؟",
        "sources": "- [Best practices for RESTful web API design - Azure - Microsoft Learn](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design)\n- [REST API Best Practices - restfulapi.net](https://restfulapi.net/rest-api-best-practices/)"
      },
      "error": ""
    },
    {
      "input": "معايير كتابة الكود النظيف: Clean Code Principles, SOLID Principles, DRY/KISS/YAGNI, Code Review Best Practices, Testing (Unit, Integration, E2E), TypeScript Best Practices, ESLint/Prettier Configuration",
      "output": {
        "topic_title": "معايير كتابة الكود النظيف",
        "introduction": "في عالم تطوير البرمجيات، لا يقتصر النجاح على كتابة كود يعمل وحسب، بل يمتد ليشمل جودة هذا الكود وسهولة قراءته وصيانته وتطويره. من هنا، تبرز أهمية \"الكود النظيف\" (Clean Code)، وهو ليس مجرد مصطلح تقني، بل هو فلسفة ومنهجية عمل تهدف إلى إنتاج برمجيات عالية الجودة، قابلة للتطوير، ومفهومة من قبل فريق العمل. إن الالتزام بمبادئ الكود النظيف يقلل من الديون التقنية، ويسرّع من وتيرة التطوير على المدى الطويل، ويعزز من التعاون بين المطورين.\n\nهذا التقرير يقدم بحثًا معمقًا وشاملاً حول معايير كتابة الكود النظيف، مستعرضًا المبادئ الأساسية مثل SOLID، DRY/KISS/YAGNI، وأفضل الممارسات في مراجعة الكود، والاختبار، واستخدام أدوات مثل TypeScript و ESLint/Prettier. الهدف هو تزويد المطورين بدليل عملي متكامل يساعدهم على الارتقاء بجودة الكود الذي يكتبونه.",
        "key_concepts": "لفهم الكود النظيف، لا بد من الإلمام بمجموعة من المفاهيم والمبادئ الأساسية التي تشكل حجر الزاوية في هذه المنهجية. هذه المبادئ ليست قواعد صارمة بقدر ما هي إرشادات تساعد المطورين على اتخاذ قرارات تصميمية أفضل.\n\n| المبدأ | الشرح |\n| --- | --- |\n| **SOLID** | مجموعة من خمسة مبادئ أساسية في البرمجة الكائنية (OOP) تساعد في بناء أنظمة برمجية مرنة وقابلة للصيانة. |\n| **DRY (Don't Repeat Yourself)** | مبدأ \"لا تكرر نفسك\" ينص على أن كل جزء من المعرفة يجب أن يكون له تمثيل واحد لا لبس فيه وموثوق به داخل النظام. |\n| **KISS (Keep It Simple, Stupid)** | مبدأ \"اجعلها بسيطة يا غبي\" يؤكد على أن البساطة يجب أن تكون هدفًا رئيسيًا في التصميم، ويجب تجنب التعقيد غير الضروري. |\n| **YAGNI (You Ain't Gonna Need It)** | مبدأ \"أنت لن تحتاج إليه\" هو ممارسة في البرمجة المتطرفة (XP) تنص على أنه لا ينبغي إضافة وظائف حتى تصبح ضرورية. |\n| **مراجعة الكود (Code Review)** | عملية منهجية لفحص كود المصدر من قبل مطورين آخرين بهدف إيجاد الأخطاء، وتحسين جودة الكود، ومشاركة المعرفة. |\n| **الاختبار (Testing)** | عملية تقييم البرنامج بهدف التأكد من أنه يلبي المتطلبات المحددة ويعمل كما هو متوقع. يشمل اختبار الوحدة، والتكامل، ومن طرف إلى طرف. |",
        "best_practices": "تتجاوز كتابة الكود النظيف مجرد اتباع المبادئ؛ إنها تتطلب تبني مجموعة من أفضل الممارسات التي تضمن جودة الكود واستدامته.\n\n*   **أسماء ذات معنى:** اختر أسماء واضحة وذات معنى للمتغيرات والدوال والفئات. يجب أن يصف الاسم الغرض من الكيان الذي يمثله.\n*   **دوال قصيرة ومركزة:** يجب أن تقوم كل دالة بمهمة واحدة فقط، وأن تكون قصيرة بما يكفي لفهمها بسهولة. هذا يتماشى مع مبدأ المسؤولية الواحدة (SRP).\n*   **التعليقات عند الضرورة فقط:** الكود الجيد يشرح نفسه بنفسه. استخدم التعليقات لشرح \"لماذا\" تم اتخاذ قرار معين، وليس \"ماذا\" يفعله الكود.\n*   **التنسيق المتسق:** اتبع دليل أسلوب متسق للتنسيق (مثل المسافات البادئة، والأقواس، وما إلى ذلك) لزيادة قابلية القراءة. أدوات مثل Prettier تساعد في فرض هذا تلقائيًا.\n*   **معالجة الأخطاء:** تعامل مع الأخطاء بشكل رشيق وقدم رسائل خطأ واضحة. لا تتجاهل الاستثناءات أو تتركها فارغة.\n*   **إعادة الهيكلة (Refactoring):** قم بتحسين تصميم الكود الحالي باستمرار دون تغيير سلوكه الخارجي. هذا يساعد على إبقاء الكود نظيفًا وسهل الصيانة.",
        "tools_technologies": "تلعب الأدوات والتقنيات دورًا حاسمًا في تطبيق معايير الكود النظيف وأتمتة العديد من جوانبها.\n\n*   **TypeScript:** هي مجموعة شاملة من JavaScript تضيف أنواعًا ثابتة اختيارية. تساعد TypeScript في اكتشاف الأخطاء مبكرًا أثناء التطوير وتجعل الكود أكثر قوة وقابلية للصيانة من خلال توثيق أنواع البيانات.\n*   **ESLint:** أداة تحليل كود ثابتة قابلة للتوصيل والإعداد بدرجة عالية. تساعد في العثور على الأنماط الإشكالية في كود JavaScript و TypeScript وإصلاحها، مما يضمن اتباع معايير الترميز المحددة.\n*   **Prettier:** أداة تنسيق كود \"عنيدة\". تفرض أسلوبًا متسقًا عن طريق تحليل الكود وإعادة طباعته بقواعدها الخاصة، مما يزيل الجدل حول أسلوب التنسيق في مراجعات الكود.\n*   **أطر الاختبار (Testing Frameworks):** مثل Jest و Mocha و Cypress، توفر بيئة وأدوات لكتابة وتشغيل اختبارات الوحدة والتكامل و E2E، مما يضمن موثوقية الكود.",
        "code_examples": "لتوضيح المبادئ، إليك بعض الأمثلة العملية.\n\n**مثال على مبدأ المسؤولية الواحدة (SRP):**\n\n```javascript\n// سيء: فئة واحدة بمسؤوليات متعددة\nclass User { \n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  sendEmail(subject, body) {\n    // منطق إرسال البريد الإلكتروني\n  }\n\n  saveToDatabase() {\n    // منطق الحفظ في قاعدة البيانات\n  }\n}\n\n// جيد: فصل المسؤوليات\nclass User {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n}\n\nclass EmailService {\n  send(user, subject, body) {\n    // منطق إرسال البريد الإلكتروني\n  }\n}\n\nclass UserRepository {\n  save(user) {\n    // منطق الحفظ في قاعدة البيانات\n  }\n}\n```\n\n**مثال على مبدأ \"لا تكرر نفسك\" (DRY):**\n\n```javascript\n// سيء: تكرار الكود\nfunction calculateTotalPriceWithTax(price) {\n  const tax = price * 0.15;\n  return price + tax;\n}\n\nfunction calculateDiscountedPriceWithTax(price, discount) {\n  const discountedPrice = price - (price * discount);\n  const tax = discountedPrice * 0.15;\n  return discountedPrice + tax;\n}\n\n// جيد: إعادة استخدام الكود\nfunction addTax(price) {\n  return price * 1.15;\n}\n\nfunction calculateTotalPriceWithTax(price) {\n  return addTax(price);\n}\n\nfunction calculateDiscountedPriceWithTax(price, discount) {\n  const discountedPrice = price - (price * discount);\n  return addTax(discountedPrice);\n}\n```",
        "practical_tips": "1.  **ابدأ صغيرًا:** لا تحاول تطبيق كل المبادئ دفعة واحدة. اختر مبدأ أو ممارسة واحدة وركز عليها.\n2.  **اجعل مراجعة الكود عادة:** قم بإجراء مراجعات كود منتظمة مع فريقك. إنها فرصة رائعة لتعلم ومشاركة أفضل الممارسات.\n3.  **استخدم الأدوات بفعالية:** قم بإعداد ESLint و Prettier في مشروعك لفرض معايير الترميز والتنسيق تلقائيًا.\n4.  **اكتب الاختبارات أولاً (TDD):** يمكن أن يساعدك تطوير الاختبارات أولاً (Test-Driven Development) على كتابة كود أنظف وأكثر تركيزًا.\n5.  **اقرأ الكود:** اقضِ وقتًا في قراءة الكود المكتوب من قبل مطورين آخرين، خاصة في المشاريع المفتوحة المصدر المعروفة بجودتها.\n6.  **لا تخف من إعادة الهيكلة:** إذا رأيت جزءًا من الكود يمكن تحسينه، فلا تتردد في إعادة هيكلته (مع وجود اختبارات تضمن عدم كسر أي شيء).",
        "common_mistakes": "*   **التحسين المبكر (Premature Optimization):** قضاء الكثير من الوقت في تحسين الكود قبل أن يكون ذلك ضروريًا، مما يؤدي إلى تعقيد غير مبرر.\n*   **التعليقات المفرطة أو عديمة الفائدة:** كتابة تعليقات تشرح \"ماذا\" يفعله الكود بدلاً من \"لماذا\".\n*   **أسماء غامضة:** استخدام أسماء متغيرات ودوال من حرف واحد أو أسماء لا تصف الغرض منها بوضوح.\n*   **تجاهل مبادئ SOLID:** يؤدي إلى كود مترابط بشدة وصعب التعديل والصيانة.\n*   **عدم كتابة الاختبارات:** الاعتقاد بأن كتابة الاختبارات مضيعة للوقت، مما يؤدي إلى كود هش وصعب التغيير بثقة.",
        "checklist": "*   [ ] هل الأسماء واضحة وذات معنى؟\n*   [ ] هل كل دالة تقوم بمهمة واحدة فقط؟\n*   [ ] هل هناك أي كود مكرر يمكن إعادة هيكلته؟\n*   [ ] هل الكود بسيط قدر الإمكان؟\n*   [ ] هل التعليقات (إن وجدت) تشرح \"لماذا\" وليس \"ماذا\"؟\n*   [ ] هل تم التعامل مع حالات الخطأ بشكل صحيح؟\n*   [ ] هل الكود مغطى باختبارات كافية (وحدة، تكامل)؟\n*   [ ] هل يتبع الكود دليل الأسلوب المتفق عليه؟\n*   [ ] هل تم تطبيق مبادئ SOLID بشكل مناسب؟",
        "sources": "1.  [What Is Clean Code? A Guide to Principles and Best Practices](https://blog.codacy.com/what-is-clean-code)\n2.  [A Solid Guide to SOLID Principles](https://www.baeldung.com/solid-principles)\n3.  [DRY, KISS & YAGNI Principles: Guide & Benefits](https://www.boldare.com/blog/kiss-yagni-dry-principles/)\n4.  [How to do a code review](https://google.github.io/eng-practices/review/reviewer/)\n5.  [Unit, Integration, and End-to-End Testing: What’s the Difference?](https://www.twilio.com/en-us/blog/unit-integration-end-to-end-testing-difference)\n6.  [TypeScript: Do's and Don'ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n7.  [ESLint - Pluggable JavaScript Linter](https://eslint.org/)\n8.  [Prettier - Opinionated Code Formatter](https://prettier.io/)"
      },
      "error": ""
    },
    {
      "input": "إدارة الحالة والتخزين المؤقت: State Management (Redux, Zustand, Context), Redis Caching, CDN Configuration, Browser Caching, Service Workers, HTTP Caching Headers, Cache Invalidation Strategies",
      "output": {
        "topic_title": "إدارة الحالة والتخزين المؤقت في تطبيقات الويب",
        "introduction": "تعتبر إدارة الحالة (State Management) والتخزين المؤقت (Caching) من المفاهيم الجوهرية في تطوير تطبيقات الويب الحديثة. فهما يلعبان دوراً حاسماً في تحسين أداء التطبيقات، تجاوبها، وقابليتها للتوسع. إدارة الحالة تضمن بقاء واجهة المستخدم متزامنة مع بيانات التطبيق، بينما يقلل التخزين المؤقت من زمن الوصول للبيانات والموارد، مما يوفر تجربة مستخدم سريعة وسلسة. في هذا الدليل، سنستكشف بعمق هذين المفهومين، ونستعرض أبرز الأدوات والتقنيات المستخدمة مثل Redux و Zustand لإدارة الحالة، و Redis و CDNs للتخزين المؤقت، مع تقديم أفضل الممارسات وأمثلة عملية لتطبيقها بفعالية في مشاريعك.",
        "key_concepts": "> إدارة الحالة (State Management) هي عملية إدارة البيانات التي تتغير بمرور الوقت في تطبيق ما. في تطبيقات الويب، تشير \"الحالة\" إلى أي بيانات يمكن أن تتغير، مثل إدخال المستخدم، أو البيانات التي يتم جلبها من واجهة برمجة التطبيقات (API)، أو حالة واجهة المستخدم (UI) مثل ما إذا كانت القائمة منسدلة مفتوحة أم لا.\n\n> التخزين المؤقت (Caching) هو عملية تخزين نسخ من الملفات أو البيانات في مكان مؤقت (ذاكرة تخزين مؤقت) بحيث يمكن الوصول إليها بسرعة أكبر في المستقبل. الهدف من التخزين المؤقت هو تقليل زمن الوصول إلى البيانات وتقليل الحمل على الخادم أو الشبكة.\n\n### المفاهيم الأساسية في إدارة الحالة:\n\n*   **Redux:** مكتبة JavaScript لإدارة حالة التطبيق. تساعدك على كتابة تطبيقات تتصرف بشكل متسق، وتعمل في بيئات مختلفة (العميل والخادم و native)، وهي سهلة الاختبار. المبدأ الأساسي لـ Redux هو وجود \"مخزن\" واحد (store) للحالة بأكملها في تطبيقك، وهو ما يجعل من السهل تتبع التغييرات وتصحيح الأخطاء.\n*   **Zustand:** مكتبة إدارة حالة بسيطة وسريعة لـ React. تعتمد على Hooks وتوفر واجهة برمجة تطبيقات (API) سهلة الاستخدام لإنشاء مخازن (stores) للحالة. تتميز Zustand بأنها لا تتطلب الكثير من الإعدادات المعقدة مقارنة بـ Redux.\n*   **Context API:** واجهة برمجة تطبيقات (API) مدمجة في React تسمح لك بمشاركة الحالة بين المكونات دون الحاجة إلى تمرير الخصائص (props) يدوياً عبر كل مستوى من شجرة المكونات. إنها مفيدة للحالات التي لا تتغير كثيراً أو للتطبيقات الصغيرة.\n\n### المفاهيم الأساسية في التخزين المؤقت:\n\n*   **Redis Caching:** Redis هو مخزن بيانات في الذاكرة (in-memory data store) يستخدم كقاعدة بيانات، وذاكرة تخزين مؤقت، ووسيط رسائل. يتميز Redis بسرعته الفائقة لأنه يخزن البيانات في الذاكرة الرئيسية (RAM)، مما يجعله مثالياً للتخزين المؤقت للبيانات التي يتم الوصول إليها بشكل متكرر.\n*   **CDN Configuration (Content Delivery Network):** شبكة توصيل المحتوى (CDN) هي شبكة من الخوادم الموزعة جغرافياً تعمل معاً لتوفير تسليم سريع لمحتوى الإنترنت. تقوم شبكات CDN بتخزين نسخ من المحتوى (مثل الصور وملفات CSS و JavaScript) في مواقع متعددة حول العالم، بحيث يتم تقديم المحتوى للمستخدمين من أقرب خادم، مما يقلل من زمن الوصول ويحسن سرعة تحميل الصفحة.\n*   **Browser Caching:** يقوم متصفح الويب بتخزين الموارد (مثل الصور وملفات CSS و JavaScript) محلياً على جهاز المستخدم. عندما يزور المستخدم نفس الموقع مرة أخرى، يمكن للمتصفح تحميل هذه الموارد من ذاكرة التخزين المؤقت المحلية بدلاً من إعادة تنزيلها من الخادم، مما يسرع بشكل كبير من أوقات تحميل الصفحات اللاحقة.\n*   **Service Workers:** هو نوع من نصوص الويب (script) التي تعمل في الخلفية، منفصلة عن صفحة الويب، وتفتح الباب أمام ميزات لا تحتاج إلى صفحة ويب أو تفاعل المستخدم. يمكن لـ Service Workers اعتراض طلبات الشبكة والتحكم فيها، وتخزين الموارد مؤقتاً بشكل فعال، مما يتيح إمكانية الوصول إلى المحتوى في وضع عدم الاتصال (offline).\n*   **HTTP Caching Headers:** هي توجيهات يتم إرسالها مع استجابات HTTP من الخادم للتحكم في كيفية تخزين الموارد مؤقتاً بواسطة المتصفح والوسطاء الآخرين (مثل شبكات CDN). من الأمثلة على هذه الترويسات `Cache-Control` و `Expires` و `ETag`.\n*   **Cache Invalidation Strategies:** هي الاستراتيجيات المستخدمة لتحديد متى يجب إزالة البيانات من ذاكرة التخزين المؤقت أو تحديثها. من المهم جداً أن تكون لديك استراتيجية لإبطال صلاحية ذاكرة التخزين المؤقت لضمان حصول المستخدمين على أحدث البيانات. تتضمن الاستراتيجيات الشائعة إبطال الصلاحية المستند إلى الوقت (Time-to-Live أو TTL) والإبطال الصريح عند تغيير البيانات.",
        "best_practices": "### أفضل الممارسات في إدارة الحالة:\n\n*   **اختر أداة إدارة الحالة المناسبة لمشروعك:** لا يوجد حل واحد يناسب الجميع. بالنسبة للتطبيقات الصغيرة ذات الحالة البسيطة، قد تكون Context API كافية. للتطبيقات الأكبر حجماً والأكثر تعقيداً، قد يكون Redux أو Zustand خياراً أفضل. ضع في اعتبارك حجم فريقك، وتعقيد الحالة، ومتطلبات الأداء عند اتخاذ قرارك.\n*   **حافظ على حالة طبيعية (Normalized State):** تجنب تكرار البيانات في مخزن الحالة الخاص بك. بدلاً من ذلك، قم بتنظيم حالتك مثل قاعدة بيانات، حيث يتم تخزين كل جزء من البيانات في مكان واحد ويتم الرجوع إليه بواسطة معرف (ID).\n*   **استخدم المحددات (Selectors) للوصول إلى الحالة:** المحددات هي وظائف تأخذ حالة Redux كوسيطة وترجع بعض البيانات المشتقة من تلك الحالة. يساعد استخدام المحددات على فصل مكوناتك عن شكل حالة Redux، مما يسهل إعادة بناء الحالة لاحقاً.\n\n### أفضل الممارسات في التخزين المؤقت:\n\n*   **استخدم استراتيجية التخزين المؤقت المناسبة:** هناك العديد من استراتيجيات التخزين المؤقت المختلفة، مثل cache-aside و write-through و read-through. اختر الاستراتيجية التي تناسب احتياجات تطبيقك. على سبيل المثال، يعد cache-aside خياراً جيداً للتطبيقات التي تقرأ البيانات بشكل متكرر أكثر مما تكتبها.\n*   **حدد سياسات انتهاء صلاحية ذاكرة التخزين المؤقت (Cache Expiration Policies) المناسبة:** من المهم تحديد المدة التي يجب أن تظل فيها البيانات في ذاكرة التخزين المؤقت قبل أن يتم اعتبارها قديمة. يعتمد هذا على مدى حساسية البيانات للوقت. على سبيل المثال، قد يتم تخزين بيانات سوق الأوراق المالية مؤقتاً لبضع ثوانٍ فقط، بينما قد يتم تخزين منشور مدونة مؤقتاً لعدة ساعات أو أيام.\n*   **استخدم شبكة توصيل المحتوى (CDN) للمحتوى الثابت:** يمكن لشبكات CDN تحسين أداء موقع الويب الخاص بك بشكل كبير عن طريق تخزين المحتوى الثابت (مثل الصور وملفات CSS و JavaScript) مؤقتاً بالقرب من المستخدمين. هذا يقلل من زمن الوصول ويحسن سرعة تحميل الصفحة.\n*   **استخدم Service Workers للتخزين المؤقت المتقدم:** يمكن لـ Service Workers توفير إمكانات تخزين مؤقت قوية، بما في ذلك القدرة على خدمة المحتوى في وضع عدم الاتصال. يمكن أن يكون هذا مفيداً بشكل خاص لتطبيقات الويب التقدمية (PWAs).",
        "tools_technologies": "### أدوات وتقنيات إدارة الحالة:\n\n*   **Redux:** مكتبة JavaScript قوية لإدارة الحالة. توفر \"مخزنًا\" مركزيًا للحالة، مما يسهل تتبع التغييرات وتصحيح الأخطاء. تُستخدم غالبًا مع React، ولكن يمكن استخدامها مع أي إطار عمل JavaScript آخر.\n*   **Zustand:** مكتبة إدارة حالة حديثة وبسيطة لـ React. تتميز بواجهة برمجة تطبيقات (API) سهلة الاستخدام وحجمها الصغير، مما يجعلها خيارًا شائعًا للتطبيقات التي تتطلب أداءً عاليًا.\n*   **React Context API:** حل مدمج في React لمشاركة الحالة بين المكونات. إنه خيار جيد للحالات البسيطة أو للتطبيقات الصغيرة حيث لا تكون هناك حاجة إلى تعقيد Redux.\n\n### أدوات وتقنيات التخزين المؤقت:\n\n*   **Redis:** مخزن بيانات في الذاكرة عالي الأداء يستخدم بشكل شائع كذاكرة تخزين مؤقت. يوفر Redis هياكل بيانات متنوعة وأوقات استجابة سريعة للغاية.\n*   **Content Delivery Networks (CDNs):** شبكات من الخوادم الموزعة عالميًا تقوم بتخزين المحتوى الثابت مؤقتًا بالقرب من المستخدمين. من أشهر مزودي خدمات CDN: Cloudflare و Amazon CloudFront و Akamai.\n*   **Service Workers:** نصوص برمجية تعمل في الخلفية وتسمح بميزات متقدمة مثل التخزين المؤقت دون اتصال بالإنترنت واعتراض طلبات الشبكة. إنها جزء أساسي من تطبيقات الويب التقدمية (PWAs).\n*   **Varnish Cache:** مسرع تطبيقات ويب مفتوح المصدر (يُعرف أيضًا باسم وكيل التخزين المؤقت HTTP العكسي). يتم وضعه أمام خادم الويب الخاص بك لتخزين الاستجابات مؤقتًا وتقليل الحمل على الخادم.",
        "code_examples": "```javascript\n// مثال بسيط على استخدام Zustand\nimport create from 'zustand';\n\nconst useStore = create(set => ({\n  bears: 0,\n  increasePopulation: () => set(state => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 })\n}));\n\nfunction BearCounter() {\n  const bears = useStore(state => state.bears);\n  return <h1>{bears} around here ...</h1>;\n}\n\nfunction Controls() {\n  const increasePopulation = useStore(state => state.increasePopulation);\n  return <button onClick={increasePopulation}>one up</button>;\n}\n```\n\n```javascript\n// مثال على استخدام Service Worker للتخزين المؤقت\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open('my-cache').then(cache => {\n      return cache.addAll([\n        '/',\n        '/index.html',\n        '/styles.css',\n        '/script.js'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```",
        "practical_tips": "1.  **ابدأ ببساطة:** لا تفرط في تعقيد إدارة الحالة أو التخزين المؤقت في وقت مبكر جدًا. ابدأ بأبسط الحلول التي تلبي احتياجاتك وقم بالتوسع حسب الضرورة.\n2.  **استفد من أدوات المطور:** توفر معظم أدوات إدارة الحالة والتخزين المؤقت أدوات مطور قوية يمكن أن تساعدك في تصحيح الأخطاء وفهم ما يحدث تحت الغطاء.\n3.  **راقب أداء ذاكرة التخزين المؤقت:** استخدم أدوات المراقبة لتتبع نسبة النتائج الإيجابية في ذاكرة التخزين المؤقت (cache hit ratio) ومقاييس الأداء الأخرى. سيساعدك هذا على تحديد ما إذا كانت استراتيجية التخزين المؤقت الخاصة بك فعالة.\n4.  **فكر في تجربة المستخدم دون اتصال بالإنترنت:** يمكن لـ Service Workers تحسين تجربة المستخدم بشكل كبير من خلال تمكين الوصول إلى المحتوى في وضع عدم الاتصال. ضع في اعتبارك استخدامها إذا كان تطبيقك يحتاج إلى أن يكون متاحًا حتى عندما لا يكون لدى المستخدم اتصال بالإنترنت.\n5.  **لا تخزن البيانات الحساسة مؤقتًا:** تجنب تخزين المعلومات الشخصية أو البيانات الحساسة الأخرى في ذاكرة التخزين المؤقت، خاصة في ذاكرة التخزين المؤقت للمتصفح أو شبكات CDN.",
        "common_mistakes": "*   **إبطال صلاحية ذاكرة التخزين المؤقت بشكل غير صحيح:** يعد إبطال صلاحية ذاكرة التخزين المؤقت أحد أصعب جوانب التخزين المؤقت. إذا لم تقم بإبطال صلاحية ذاكرة التخزين المؤقت بشكل صحيح، فقد ينتهي الأمر بالمستخدمين إلى رؤية بيانات قديمة. تأكد من أن لديك استراتيجية قوية لإبطال صلاحية ذاكرة التخزين المؤقت.\n*   **تخزين كل شيء مؤقتًا:** ليس كل شيء بحاجة إلى التخزين المؤقت. يمكن أن يؤدي التخزين المؤقت المفرط إلى زيادة التعقيد وإهدار الموارد. ركز على تخزين البيانات التي يتم الوصول إليها بشكل متكرر والتي لا تتغير كثيرًا.\n*   **تجاهل ترويسات التحكم في ذاكرة التخزين المؤقت HTTP:** تعد ترويسات التحكم في ذاكرة التخزين المؤقت HTTP أداة قوية للتحكم في كيفية تخزين المتصفحات والوكلاء للبيانات مؤقتًا. تأكد من أنك تستخدمها بشكل صحيح لتحسين أداء موقع الويب الخاص بك.\n*   **عدم وجود استراتيجية لإدارة الحالة:** بدون استراتيجية واضحة لإدارة الحالة، يمكن أن يصبح تطبيقك سريعًا فوضويًا ويصعب الحفاظ عليه. اختر أداة لإدارة الحالة والتزم بها.",
        "checklist": "*   **إدارة الحالة:**\n    *   هل تم اختيار أداة إدارة الحالة المناسبة (Redux, Zustand, Context API) بناءً على حجم وتعقيد المشروع؟\n    *   هل يتم الحفاظ على حالة طبيعية (normalized) لتجنب تكرار البيانات؟\n    *   هل يتم استخدام المحددات (selectors) للوصول إلى الحالة بطريقة فعالة؟\n*   **التخزين المؤقت:**\n    *   هل تم تطبيق استراتيجية تخزين مؤقت مناسبة (cache-aside, write-through)؟\n    *   هل تم تكوين سياسات انتهاء صلاحية ذاكرة التخزين المؤقت (cache expiration) بشكل صحيح؟\n    *   هل يتم استخدام شبكة توصيل المحتوى (CDN) للمحتوى الثابت؟\n    *   هل يتم استخدام Service Workers للتخزين المؤقت المتقدم ودعم العمل دون اتصال بالإنترنت؟\n    *   هل تم تكوين ترويسات التحكم في ذاكرة التخزين المؤقت HTTP بشكل صحيح؟",
        "sources": "https://developer.mozilla.org/\nhttps://developers.google.com/\nhttps://aws.amazon.com/documentation/\nhttps://docs.microsoft.com/\nhttps://redux.js.org/\nhttps://github.com/pmndrs/zustand\nhttps://redis.io/documentation"
      },
      "error": ""
    },
    {
      "input": "تجربة المستخدم UX والوصولية: Accessibility (WCAG 2.1), Semantic HTML, ARIA Labels, Keyboard Navigation, Screen Reader Support, Color Contrast, Loading States, Error Messages, Form Validation UX",
      "output": {
        "topic_title": "تجربة المستخدم (UX) والوصولية (Accessibility) في تطوير الويب",
        "introduction": "تُعد تجربة المستخدم (UX) والوصولية (Accessibility) من الركائز الأساسية في تطوير الويب الحديث. ففي عالم يتزايد فيه الاعتماد على الإنترنت في كافة جوانب الحياة، لم يعد كافيًا أن يكون الموقع الإلكتروني فعالًا من الناحية التقنية فحسب، بل يجب أن يكون سهل الاستخدام ومتاحًا للجميع، بغض النظر عن قدراتهم الجسدية أو العقلية. تهدف تجربة المستخدم إلى خلق تفاعل إيجابي وممتع بين المستخدم والموقع، مما يزيد من رضاه وولائه. أما الوصولية، فهي تضمن أن يتمكن الأشخاص ذوو الإعاقة من الوصول إلى المحتوى والخدمات الرقمية واستخدامها بفعالية. إن التكامل بين هذين المفهومين لا يساهم فقط في بناء مواقع أكثر شمولية وعدالة، بل يعزز أيضًا من جودة الموقع بشكل عام، ويوسع قاعدة المستخدمين، ويحسن من سمعة العلامة التجارية.",
        "key_concepts": "### المفاهيم الأساسية\n\n**تجربة المستخدم (User Experience - UX):**\nهي كل ما يتعلق بتفاعل المستخدم مع المنتج أو الخدمة، وتشمل مشاعره، وتصوراته، وسلوكياته. في سياق تطوير الويب، تركز تجربة المستخدم على تصميم مواقع سهلة الاستخدام، وممتعة، وتلبي احتياجات المستخدمين بشكل فعال.\n\n**الوصولية (Accessibility):**\nهي ممارسة تصميم وتطوير المواقع والتطبيقات بحيث يمكن للأشخاص ذوي الإعاقة استخدامها. تشمل الوصولية جميع الإعاقات التي تؤثر على الوصول إلى الويب، بما في ذلك الإعاقات السمعية، والبصرية، والجسدية، والعصبية، والمعرفية. الهدف هو إزالة الحواجز التي تمنع التفاعل مع الويب أو الوصول إليه.\n\n**إرشادات الوصول إلى محتوى الويب (WCAG):**\nهي مجموعة من الإرشادات والمعايير الدولية التي تهدف إلى جعل محتوى الويب أكثر قابلية للوصول للأشخاص ذوي الإعاقة. الإصدار 2.1 هو أحدث إصدار، ويركز على أربعة مبادئ أساسية: الإدراك، والتشغيل، والفهم، والمتانة.\n\n**HTML الدلالي (Semantic HTML):**\nهو استخدام عناصر HTML بناءً على معناها والغرض منها، وليس فقط لغرض العرض. على سبيل المثال، استخدام `<nav>` للملاحة، و`<article>` للمقالات، و`<h1>` للعناوين الرئيسية. يساعد HTML الدلالي محركات البحث وقارئات الشاشة على فهم بنية المحتوى بشكل أفضل.\n\n**ARIA (Accessible Rich Internet Applications):**\nهي مجموعة من السمات التي يمكن إضافتها إلى عناصر HTML لتحسين الوصولية، خاصة في التطبيقات الديناميكية والمعقدة. تساعد ARIA في توفير معلومات إضافية حول الأدوار والحالات والخصائص للعناصر التي لا يمكن التعبير عنها باستخدام HTML الدلالي وحده.\n\n**ملصقات ARIA (ARIA Labels):**\nهي سمات ARIA تُستخدم لتوفير اسم أو وصف نصي لعنصر ما، خاصة عندما لا يكون هناك نص مرئي يصف العنصر بشكل كافٍ. على سبيل المثال، يمكن استخدام `aria-label` لوصف زر يحتوي على أيقونة فقط.\n\n**التنقل باستخدام لوحة المفاتيح (Keyboard Navigation):**\nهو القدرة على التنقل والتفاعل مع جميع عناصر الموقع باستخدام لوحة المفاتيح فقط، دون الحاجة إلى الماوس. هذا أمر ضروري للمستخدمين الذين يعانون من إعاقات حركية، وكذلك للمستخدمين الذين يفضلون استخدام لوحة المفاتيح.\n\n**دعم قارئ الشاشة (Screen Reader Support):**\nقارئات الشاشة هي برامج تحول النص والمحتوى الرقمي إلى كلام مسموع أو إلى طريقة برايل. يعد دعم قارئات الشاشة أمرًا بالغ الأهمية للمستخدمين المكفوفين وضعاف البصر، ويتطلب تصميمًا وبرمجة دقيقة لضمان أن يتمكنوا من فهم المحتوى والتفاعل معه.\n\n**تباين الألوان (Color Contrast):**\nهو الفرق في السطوع بين لون الخلفية ولون النص أو العنصر الأمامي. يجب أن يكون التباين كافيًا لضمان أن يتمكن الأشخاص الذين يعانون من ضعف في الرؤية أو عمى الألوان من قراءة المحتوى بسهولة.\n\n**حالات التحميل (Loading States):**\nهي مؤشرات مرئية تُعلم المستخدم بأن المحتوى قيد التحميل أو أن هناك عملية جارية في الخلفية. يجب أن تكون حالات التحميل واضحة ومفهومة، وأن لا تعيق تجربة المستخدم.\n\n**رسائل الخطأ (Error Messages):**\nهي رسائل تُعرض للمستخدم عند حدوث خطأ ما، مثل إدخال بيانات غير صحيحة في نموذج. يجب أن تكون رسائل الخطأ واضحة، وموجزة، وتوضح سبب الخطأ وكيفية إصلاحه.\n\n**تجربة المستخدم في التحقق من صحة النماذج (Form Validation UX):**\nهي الطريقة التي يتم بها تصميم عملية التحقق من صحة البيانات في النماذج. يجب أن تكون هذه العملية سهلة الاستخدام، وتوفر ملاحظات فورية وواضحة للمستخدم حول الأخطاء التي ارتكبها.",
        "best_practices": "### أفضل الممارسات\n\n**1. استخدام HTML الدلالي (Semantic HTML):**\n- **الوصف:** استخدم دائمًا عناصر HTML المناسبة للغرض منها. على سبيل المثال، استخدم `<nav>` للملاحة، و`<main>` للمحتوى الرئيسي، و`<footer>` للتذييل. يساعد ذلك قارئات الشاشة ومحركات البحث على فهم بنية صفحتك.\n- **الممارسة:** تجنب استخدام عناصر `<div>` و`<span>` لكل شيء. بدلاً من ذلك، اختر العنصر الدلالي الذي يصف المحتوى بشكل أفضل.\n\n**2. توفير نص بديل للصور (Alt Text):**\n- **الوصف:** يجب أن تحتوي جميع الصور على سمة `alt` تصف محتوى الصورة. إذا كانت الصورة زخرفية بحتة، فاترك السمة فارغة (`alt=\"\"`).\n- **الممارسة:** يجب أن يكون النص البديل موجزًا وصفيًا. على سبيل المثال، بدلاً من `alt=\"صورة\"`، استخدم `alt=\"شعار شركة جوجل\"`.\n\n**3. ضمان إمكانية الوصول عبر لوحة المفاتيح:**\n- **الوصف:** يجب أن تكون جميع العناصر التفاعلية (الروابط، الأزرار، حقول النماذج) قابلة للوصول والتشغيل باستخدام لوحة المفاتيح فقط.\n- **الممارسة:** اختبر موقعك عن طريق التنقل باستخدام مفتاح `Tab`. تأكد من وجود مؤشر تركيز مرئي وواضح (focus indicator) على العنصر النشط.\n\n**4. استخدام ARIA بحكمة:**\n- **الوصف:** استخدم سمات ARIA (Accessible Rich Internet Applications) لتحسين إمكانية الوصول للتطبيقات الديناميكية والمكونات المخصصة التي لا يمكن وصفها باستخدام HTML الدلالي وحده.\n- **الممارسة:** لا تفرط في استخدام ARIA. القاعدة الأولى لـ ARIA هي \"لا تستخدم ARIA\". إذا كان بإمكانك استخدام عنصر HTML دلالي، فافعل ذلك.\n\n**5. الاهتمام بتباين الألوان:**\n- **الوصف:** يجب أن يكون هناك تباين كافٍ بين لون النص ولون الخلفية لضمان سهولة القراءة، خاصة للمستخدمين الذين يعانون من ضعف في الرؤية.\n- **الممارسة:** استخدم أدوات فحص تباين الألوان للتأكد من أنك تلبي الحد الأدنى من معايير WCAG (4.5:1 للنص العادي و 3:1 للنص الكبير).\n\n**6. تصميم نماذج يمكن الوصول إليها:**\n- **الوصف:** يجب أن تكون النماذج سهلة الفهم والتعبئة. استخدم عناصر `<label>` لربط التسميات بحقول الإدخال الخاصة بها.\n- **الممارسة:** قدم رسائل خطأ واضحة ومفيدة. يجب أن توضح الرسالة ما هو الخطأ وكيفية إصلاحه. ضع الرسالة بالقرب من الحقل الذي يحتوي على الخطأ.\n\n**7. بنية العناوين المنطقية:**\n- **الوصف:** استخدم العناوين (`<h1>` - `<h6>`) لإنشاء بنية هرمية للمحتوى. يجب أن يكون هناك `<h1>` واحد فقط في كل صفحة.\n- **الممارسة:** لا تتخطى مستويات العناوين (على سبيل المثال، لا تنتقل من `<h2>` إلى `<h4>`). استخدم العناوين لتقسيم المحتوى إلى أقسام منطقية.\n\n**8. توفير روابط \"تخطي\" (Skip Links):**\n- **الوصف:** قم بتضمين رابط في أعلى الصفحة يسمح لمستخدمي لوحة المفاتيح بتخطي التنقل المتكرر والانتقال مباشرة إلى المحتوى الرئيسي.\n- **الممارسة:** يجب أن يكون رابط \"تخطي إلى المحتوى الرئيسي\" هو أول عنصر قابل للتركيز في الصفحة.\n\n**9. تصميم حالات التحميل والخطأ بشكل جيد:**\n- **الوصف:** أبلغ المستخدمين بوضوح عندما يتم تحميل المحتوى أو عند حدوث خطأ. استخدم مؤشرات تحميل مرئية ورسائل خطأ مفيدة.\n- **الممارسة:** بالنسبة لحالات التحميل، استخدم `aria-busy=\"true\"` لإعلام قارئات الشاشة بأن جزءًا من الصفحة قيد التحديث. بالنسبة للأخطاء، استخدم `role=\"alert\"` للإعلان عن الرسائل المهمة.\n\n**10. الاختبار باستخدام التقنيات المساعدة:**\n- **الوصف:** لا تعتمد فقط على الاختبارات الآلية. اختبر موقعك باستخدام قارئات الشاشة (مثل NVDA أو VoiceOver) وتصفحه باستخدام لوحة المفاتيح فقط.\n- **الممارسة:** قم بإجراء اختبارات مع مستخدمين حقيقيين من ذوي الإعاقة للحصول على ملاحظات قيمة حول تجربة استخدام موقعك.",
        "tools_technologies": "### الأدوات والتقنيات\n\n**1. أدوات فحص الوصولية الآلية:**\n- **الوصف:** هذه الأدوات تقوم بفحص موقعك تلقائيًا وتحديد مشكلات الوصولية الشائعة. إنها نقطة انطلاق جيدة، لكنها لا تكتشف جميع المشكلات.\n- **أمثلة:**\n  - **Lighthouse (في أدوات مطوري Chrome):** أداة مدمجة في متصفح Chrome توفر تدقيقًا للوصولية والأداء وأفضل الممارسات.\n  - **axe DevTools:** امتداد للمتصفح (Chrome, Firefox, Edge) يقوم بتحليل الصفحة وتحديد انتهاكات WCAG.\n  - **WAVE:** أداة تقييم الوصولية على الويب، متاحة كملحق للمتصفح أو عبر الإنترنت.\n\n**2. قارئات الشاشة (Screen Readers):**\n- **الوصف:** برامج أساسية للمستخدمين المكفوفين وضعاف البصر. يساعد اختبار موقعك باستخدامها على فهم كيفية تجربة هؤلاء المستخدمين للمحتوى الخاص بك.\n- **أمثلة:**\n  - **NVDA (NonVisual Desktop Access):** قارئ شاشة مجاني ومفتوح المصدر لنظام Windows.\n  - **JAWS (Job Access With Speech):** قارئ شاشة شائع لنظام Windows (تجاري).\n  - **VoiceOver:** قارئ شاشة مدمج في أجهزة Apple (macOS, iOS).\n  - **TalkBack:** قارئ شاشة مدمج في نظام Android.\n\n**3. أدوات فحص تباين الألوان:**\n- **الوصف:** تساعدك هذه الأدوات على التأكد من أن تباين الألوان بين النص والخلفية يفي بمعايير WCAG.\n- **أمثلة:**\n  - **WebAIM Contrast Checker:** أداة بسيطة عبر الإنترنت للتحقق من تباين الألوان.\n  - **Adobe Color Contrast Analyzer:** أداة لسطح المكتب لتحليل تباين الألوان.\n  - **Coolors Contrast Checker:** أداة أخرى سهلة الاستخدام عبر الإنترنت.\n\n**4. HTML و ARIA:**\n- **الوصف:** HTML الدلالي هو أساس الوصولية. توفر ARIA (Accessible Rich Internet Applications) سمات إضافية لتعزيز الوصولية في المحتوى الديناميكي.\n- **التقنيات:**\n  - **HTML5 Semantic Elements:** مثل `<header>`, `<nav>`, `<main>`, `<article>`, `<footer>`.\n  - **ARIA Roles, States, and Properties:** مثل `role=\"navigation\"`, `aria-label`, `aria-describedby`, `aria-hidden`.\n\n**5. لغات البرمجة والأطر (Frameworks):**\n- **الوصف:** يمكن استخدام JavaScript لتحسين الوصولية، ولكن يمكن أن يؤدي أيضًا إلى إنشاء حواجز إذا لم يتم استخدامه بشكل صحيح. العديد من أطر العمل الحديثة (مثل React, Angular, Vue) تتضمن ميزات وإرشادات للوصولية.\n- **التقنيات:**\n  - **JavaScript:** لإدارة التركيز (focus management)، والإعلان عن التغييرات الديناميكية، وإنشاء مكونات مخصصة يمكن الوصول إليها.\n  - **React-axe, eslint-plugin-jsx-a11y:** أدوات لمساعدة مطوري React على كتابة كود يمكن الوصول إليه.\n\n**6. أدوات المحاكاة والاختبار:**\n- **الوصف:** أدوات تحاكي كيف يمكن أن يظهر موقعك للمستخدمين الذين يعانون من أنواع مختلفة من عمى الألوان أو ضعف البصر.\n- **أمثلة:**\n  - **NoCoffee (امتداد لمتصفح Chrome):** يحاكي مجموعة متنوعة من الإعاقات البصرية.\n  - **أدوات المطور في المتصفحات:** تحتوي معظم المتصفحات على أدوات لمحاكاة ظروف الشبكة المختلفة والأجهزة المختلفة.",
        "code_examples": "### أمثلة الكود\n\n**1. مثال على HTML الدلالي:**\n\n```html\n<!-- هيكل صفحة دلالي -->\n<header>\n  <h1>عنوان الموقع</h1>\n  <nav>\n    <ul>\n      <li><a href=\"/\">الرئيسية</a></li>\n      <li><a href=\"/about\">من نحن</a></li>\n      <li><a href=\"/contact\">اتصل بنا</a></li>\n    </ul>\n  </nav>\n</header>\n\n<main>\n  <article>\n    <h2>عنوان المقال</h2>\n    <p>محتوى المقال هنا...</p>\n  </article>\n</main>\n\n<footer>\n  <p>&copy; 2026 اسم الموقع. جميع الحقوق محفوظة.</p>\n</footer>\n```\n**الشرح:** يستخدم هذا المثال عناصر `<header>`، `<nav>`، `<main>`، `<article>`، و`<footer>` لتحديد بنية الصفحة بوضوح، مما يسهل على التقنيات المساعدة فهم المحتوى.\n\n**2. مثال على استخدام `aria-label`:**\n\n```html\n<!-- زر إغلاق يحتوي على أيقونة فقط -->\n<button aria-label=\"إغلاق\">\n  <svg>...</svg> <!-- أيقونة X -->\n</button>\n```\n**الشرح:** بما أن الزر لا يحتوي على نص مرئي، فإن `aria-label=\"إغلاق\"` يوفر اسمًا يمكن الوصول إليه لقارئات الشاشة، مما يوضح وظيفة الزر.\n\n**3. مثال على نموذج يمكن الوصول إليه:**\n\n```html\n<form>\n  <div>\n    <label for=\"username\">اسم المستخدم:</label>\n    <input type=\"text\" id=\"username\" name=\"username\" required aria-describedby=\"username-hint\">\n    <p id=\"username-hint\">يجب أن يكون اسم المستخدم فريدًا.</p>\n  </div>\n  \n  <div>\n    <label for=\"password\">كلمة المرور:</label>\n    <input type=\"password\" id=\"password\" name=\"password\" required aria-describedby=\"password-error\">\n    <p id=\"password-error\" role=\"alert\" style=\"display:none;\">كلمة المرور قصيرة جدًا.</p>\n  </div>\n\n  <button type=\"submit\">تسجيل الدخول</button>\n</form>\n```\n**الشرح:**\n- يتم ربط كل `<label>` بحقل `<input>` الخاص به باستخدام السمة `for`.\n- `aria-describedby` تُستخدم لربط حقول الإدخال بتلميحات أو رسائل خطأ إضافية.\n- `role=\"alert\"` على رسالة الخطأ يجعل قارئات الشاشة تعلن عنها فور ظهورها.\n\n**4. مثال على رابط \"تخطي إلى المحتوى الرئيسي\":**\n\n```html\n<body>\n  <a href=\"#main-content\" class=\"skip-link\">تخطي إلى المحتوى الرئيسي</a>\n  \n  <header>\n    <!-- محتوى الهيدر -->\n  </header>\n  \n  <main id=\"main-content\">\n    <!-- المحتوى الرئيسي للصفحة -->\n  </main>\n</body>\n```\n```css\n.skip-link {\n  position: absolute;\n  left: -9999px;\n}\n\n.skip-link:focus {\n  left: 10px;\n  top: 10px;\n  background-color: #000;\n  color: #fff;\n  padding: 5px;\n}\n```\n**الشرح:** الرابط مخفي بشكل افتراضي ولكنه يظهر عندما يحصل على التركيز (عند الضغط على مفتاح `Tab` لأول مرة)، مما يسمح للمستخدمين بتجاوز التنقل والوصول مباشرة إلى `<main>`.",
        "practical_tips": "### نصائح عملية\n\n1.  **ابدأ بالوصولية من اليوم الأول:** دمج الوصولية في مرحلة التصميم والتطوير الأولية أسهل وأقل تكلفة من محاولة إصلاح المشكلات لاحقًا.\n2.  **فكر في جميع المستخدمين:** عند التصميم، لا تفترض أن جميع المستخدمين يرون ويسمعون ويتفاعلون مع موقعك بنفس الطريقة. ضع في اعتبارك مجموعة واسعة من القدرات.\n3.  **اجعل البساطة هدفك:** التصاميم النظيفة والبسيطة غالبًا ما تكون أكثر قابلية للاستخدام والوصول. تجنب الفوضى البصرية والتعقيد غير الضروري.\n4.  **استخدم لوحة المفاتيح بانتظام:** اعتد على التنقل في مواقعك الخاصة باستخدام لوحة المفاتيح فقط. سيساعدك هذا على اكتشاف مشكلات التركيز والتنقل بسرعة.\n5.  **اكتب نصوصًا واضحة وموجزة:** استخدم لغة بسيطة ومباشرة. قم بتقسيم المحتوى الطويل إلى فقرات وعناوين وقوائم لتسهيل القراءة والفهم.\n6.  **لا تعتمد على اللون وحده:** لا تستخدم اللون كوسيلة وحيدة لنقل المعلومات. استخدم معه أيقونات أو نصوصًا أو أنماطًا لضمان فهم الرسالة من قبل الجميع.\n7.  **اختبر على أجهزة حقيقية:** لا تعتمد فقط على المحاكيات. اختبر موقعك على هواتف وأجهزة لوحية مختلفة، وجرب استخدام قارئات الشاشة المدمجة (VoiceOver و TalkBack).\n8.  **اطلب الملاحظات:** إذا أمكن، اطلب من الأشخاص ذوي الإعاقة اختبار موقعك وتقديم ملاحظاتهم. تجربتهم المباشرة لا تقدر بثمن.\n9.  **ابق على اطلاع:** مجال الوصولية الرقمية يتطور باستمرار. تابع مدونات الخبراء، وإرشادات W3C، والموارد الموثوقة الأخرى لتبقى على اطلاع بأحدث الممارسات.\n10. **لا تخف من ارتكاب الأخطاء:** الوصولية رحلة مستمرة وليست وجهة نهائية. الأهم هو الالتزام بالتحسين المستمر والتعلم من أين الأخطاء.",
        "common_mistakes": "### الأخطاء الشائعة وكيفية تجنبها\n\n**1. إهمال النص البديل للصور (Alt Text):**\n- **الخطأ:** ترك الصور بدون سمة `alt` أو استخدام نصوص بديلة غير وصفية (مثل `alt=\"صورة\"`).\n- **الحل:** قم دائمًا بتوفير نص بديل وصفي للصور التي تنقل معلومات. إذا كانت الصورة زخرفية، استخدم `alt=\"\"`.\n\n**2. مؤشرات التركيز غير الواضحة أو المخفية:**\n- **الخطأ:** إزالة المخطط التفصيلي للتركيز (focus outline) باستخدام `outline: none;` في CSS دون توفير بديل واضح.\n- **الحل:** حافظ على مؤشر التركيز الافتراضي للمتصفح أو قم بتصميمه ليكون أكثر وضوحًا ويتناسب مع تصميم موقعك. يجب أن يعرف مستخدمو لوحة المفاتيح دائمًا مكانهم في الصفحة.\n\n**3. استخدام HTML غير الدلالي:**\n- **الخطأ:** بناء مكونات تفاعلية (مثل الأزرار أو القوائم) باستخدام عناصر `<div>` و `<span>` فقط، مما يفقدها إمكانية الوصول المضمنة.\n- **الحل:** استخدم عناصر HTML الدلالية كلما أمكن ذلك (`<button>`, `<nav>`, `<select>`, إلخ). إذا كان لا بد من استخدام مكون مخصص، فاستخدم ARIA لإضافة الدلالات المفقودة.\n\n**4. عدم ربط التسميات بحقول النماذج:**\n- **الخطأ:** وضع تسميات نصية بجوار حقول الإدخال دون ربطها برمجيًا باستخدام `<label for=\"...\">`.\n- **الحل:** تأكد من أن كل حقل إدخال في النموذج له `<label>` مرتبط به. هذا يسمح للمستخدمين بالنقر فوق التسمية لتنشيط الحقل ويساعد قارئات الشاشة على وصف الحقل بشكل صحيح.\n\n**5. الاعتماد على اللون فقط لنقل المعلومات:**\n- **الخطأ:** استخدام اللون الأحمر فقط للإشارة إلى حقل خاطئ، أو اللون الأخضر للإشارة إلى النجاح.\n- **الحل:** استخدم دائمًا مؤشرًا إضافيًا إلى جانب اللون، مثل أيقونة، أو نص، أو نمط. هذا يضمن أن المستخدمين الذين يعانون من عمى الألوان يمكنهم فهم الرسالة.\n\n**6. رسائل الخطأ الغامضة أو غير المفيدة:**\n- **الخطأ:** عرض رسالة خطأ عامة مثل \"حدث خطأ\" دون توضيح المشكلة أو كيفية حلها.\n- **الحل:** يجب أن تكون رسائل الخطأ محددة وواضحة. أخبر المستخدم بالحقل الذي يحتوي على الخطأ، وما هو الخطأ، وما الذي يجب عليه فعله لتصحيحه.\n\n**7. المحتوى الديناميكي الذي لا يتم الإعلان عنه:**\n- **الخطأ:** تحديث المحتوى في الصفحة (مثل نتائج البحث أو رسائل الحالة) دون إعلام مستخدمي قارئات الشاشة بالتغيير.\n- **الحل:** استخدم مناطق ARIA الحية (`aria-live`) أو أدوار التنبيه (`role=\"alert\"`) للإعلان عن التغييرات الديناميكية المهمة للمستخدمين.",
        "checklist": "### قائمة التحقق\n\n**بنية المحتوى:**\n- [ ] هل الصفحة تستخدم HTML دلالي بشكل صحيح (`<header>`, `<nav>`, `<main>`, `<footer>`, إلخ)؟\n- [ ] هل هناك `<h1>` واحد فقط في الصفحة؟\n- [ ] هل بنية العناوين (`<h2>` إلى `<h6>`) منطقية ومتسلسلة؟\n- [ ] هل تم تحديد اللغة الأساسية للصفحة باستخدام `<html lang=\"...\">`؟\n\n**الصور والوسائط:**\n- [ ] هل لجميع الصور سمة `alt` وصفية؟\n- [ ] هل الصور الزخرفية لها `alt=\"\"`؟\n- [ ] هل يتم توفير نصوص أو تسميات توضيحية لمحتوى الفيديو والصوت؟\n\n**التفاعل والتنقل:**\n- [ ] هل يمكن الوصول إلى جميع العناصر التفاعلية (الروابط، الأزرار، النماذج) والتنقل بينها باستخدام لوحة المفاتيح فقط؟\n- [ ] هل مؤشر التركيز (focus indicator) مرئي وواضح دائمًا؟\n- [ ] هل ترتيب التنقل (tab order) منطقي ويتبع التدفق البصري للصفحة؟\n- [ ] هل يوجد رابط \"تخطي إلى المحتوى الرئيسي\"؟\n\n**النماذج:**\n- [ ] هل كل حقل إدخال له `<label>` مرتبط به بشكل صحيح؟\n- [ ] هل رسائل الخطأ واضحة ومحددة ومربوطة بالحقل الخاص بها؟\n- [ ] هل يتم الإعلان عن الأخطاء لمستخدمي قارئات الشاشة (باستخدام `role=\"alert\"` أو ما شابه)؟\n\n**التباين والمظهر:**\n- [ ] هل يفي تباين الألوان بين النص والخلفية بمعايير WCAG (4.5:1 على الأقل للنص العادي)؟\n- [ ] هل لا يتم استخدام اللون كوسيلة وحيدة لنقل المعلومات؟\n- [ ] هل يمكن تكبير النص حتى 200٪ دون فقدان المحتوى أو الوظائف؟\n\n**المحتوى الديناميكي و ARIA:**\n- [ ] هل يتم استخدام ARIA عند الضرورة فقط لتحسين المكونات المخصصة؟\n- [ ] هل يتم إعلام قارئات الشاشة بالتحديثات الديناميكية الهامة للمحتوى (باستخدام `aria-live`)؟\n- [ ] هل للأزرار والعناصر التفاعلية التي لا تحتوي على نص مرئي `aria-label` وصفي؟\n\n**الاختبار العام:**\n- [ ] هل تم اختبار الموقع باستخدام قارئ شاشة (مثل NVDA أو VoiceOver)؟\n- [ ] هل تم اختبار الموقع على متصفحات وأجهزة مختلفة؟",
        "sources": "### المصادر\n\n- [Introduction to Web Accessibility | Web Accessibility Initiative (WAI) | W3C](https://www.w3.org/WAI/fundamentals/accessibility-intro/)\n- [HTML: A good basis for accessibility - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML)\n- [ARIA: aria-label attribute - ARIA | MDN](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label)\n- [Keyboard Accessibility - WebAIM](https://webaim.org/techniques/keyboard/)\n- [Accessibility Screen Readers - W3Schools](https://www.w3schools.com/accessibility/accessibility_screen_readers.php)\n- [Usable and Accessible Form Validation and Error Recovery - WebAIM](https://webaim.org/techniques/formvalidation/)\n- [Color Contrast Checker - WebAIM](https://webaim.org/resources/contrastchecker/)"
      },
      "error": ""
    },
    {
      "input": "DevOps والنشر: CI/CD Pipelines, Docker Containerization, Environment Variables Management, Logging Best Practices, Error Monitoring (Sentry), Health Checks, Zero Downtime Deployment, Git Workflow",
      "output": {
        "topic_title": "DevOps والنشر: CI/CD Pipelines, Docker Containerization, Environment Variables Management, Logging Best Practices, Error Monitoring (Sentry), Health Checks, Zero Downtime Deployment, Git Workflow",
        "introduction": "يمثل DevOps تحولًا جذريًا في عالم تطوير البرمجيات، حيث يسعى إلى كسر الحواجز بين فرق التطوير (Dev) والعمليات (Ops) لتعزيز التعاون وتحقيق الكفاءة. لم يعد النشر اليدوي البطيء والمحفوف بالمخاطر خيارًا في ظل التطور السريع للتكنولوجيا والمنافسة الشديدة. تهدف ممارسات DevOps إلى أتمتة عملية تسليم البرمجيات بالكامل، بدءًا من كتابة الكود وحتى نشره في بيئة الإنتاج، مما يضمن سرعة وجودة واستقرار التطبيقات. في هذا الدليل الشامل، سنستكشف المفاهيم الأساسية وأفضل الممارسات والأدوات والتقنيات المتعلقة بـ DevOps والنشر، مع التركيز على بناء خطوط أنابيب CI/CD قوية، واستخدام Docker لتوحيد البيئات، وإدارة متغيرات البيئة بشكل آمن، وتطبيق أفضل ممارسات التسجيل والمراقبة لضمان صحة التطبيقات ونشرها بدون توقف.",
        "key_concepts": "## المفاهيم الأساسية\n\nلفهم DevOps والنشر بشكل كامل، من الضروري الإلمام بالمفاهيم والمصطلحات الأساسية التي تشكل حجر الزاوية في هذا المجال. \n\n### 1. التكامل المستمر (Continuous Integration - CI)\n\nالتكامل المستمر هو ممارسة يقوم فيها المطورون بدمج تغييراتهم البرمجية في مستودع مركزي بشكل متكرر. بعد كل عملية دمج، يتم تشغيل بناء (build) واختبارات آلية للكشف عن الأخطاء والمشكلات في وقت مبكر. الهدف من التكامل المستمر هو تبسيط عملية الدمج وتقليل المشاكل التي قد تنشأ عند دمج كميات كبيرة من التعليمات البرمجية دفعة واحدة.\n\n### 2. التسليم المستمر والنشر المستمر (Continuous Delivery/Deployment - CD)\n\n**التسليم المستمر (Continuous Delivery):** هو امتداد للتكامل المستمر، حيث يتم نشر جميع تغييرات التعليمات البرمجية التي تجتاز مرحلة البناء والاختبارات الآلية إلى بيئة اختبار أو بيئة ما قبل الإنتاج (staging). الهدف هو التأكد من أن التطبيق جاهز دائمًا للنشر في بيئة الإنتاج بنقرة زر واحدة.\n\n**النشر المستمر (Continuous Deployment):** هو الخطوة التالية بعد التسليم المستمر، حيث يتم نشر كل تغيير يجتاز جميع الاختبارات تلقائيًا إلى بيئة الإنتاج دون أي تدخل بشري. هذا يتطلب ثقة عالية في عملية الاختبار الآلي.\n\n### 3. خط أنابيب CI/CD (CI/CD Pipeline)\n\nخط أنابيب CI/CD هو سلسلة من الخطوات الآلية التي يجب أن يمر بها الكود قبل إصداره للمستخدمين. يتضمن عادةً مراحل مثل بناء الكود، وتشغيل الاختبارات (الوحدة، التكامل، وغيرها)، وتحليل جودة الكود، وأخيرًا النشر في بيئات مختلفة.\n\n### 4. الحاويات (Containerization) و Docker\n\nالحاويات هي تقنية لتغليف التطبيق وجميع تبعياته (المكتبات، الأدوات، إلخ) في وحدة واحدة معزولة تسمى \"حاوية\". هذا يضمن أن التطبيق سيعمل بنفس الطريقة بغض النظر عن البيئة التي يتم تشغيله فيها. **Docker** هو أشهر منصة لإنشاء وإدارة الحاويات.\n\n### 5. متغيرات البيئة (Environment Variables)\n\nمتغيرات البيئة هي قيم ديناميكية يمكن أن تؤثر على سلوك العمليات قيد التشغيل على جهاز الكمبيوتر. في سياق DevOps، تُستخدم متغيرات البيئة لتكوين التطبيق لبيئات مختلفة (مثل التطوير والاختبار والإنتاج) دون تغيير الكود. هذا يسمح بفصل التكوين عن الكود، وهو من أفضل الممارسات في تطوير البرمجيات.\n\n### 6. التسجيل (Logging)\n\nالتسجيل هو عملية تسجيل الأحداث والمعلومات حول تشغيل التطبيق. السجلات الجيدة ضرورية لتصحيح الأخطاء، ومراقبة أداء التطبيق، وتحليل سلوك المستخدم. **التسجيل المنظم (Structured Logging)** هو ممارسة تسجيل الرسائل بتنسيق ثابت (مثل JSON) لتسهيل تحليلها آليًا.\n\n### 7. مراقبة الأخطاء (Error Monitoring)\n\nمراقبة الأخطاء هي عملية اكتشاف وتشخيص والإبلاغ عن الأخطاء التي تحدث في التطبيق في الوقت الفعلي. أدوات مثل **Sentry** تساعد الفرق على تحديد الأخطاء وإصلاحها بسرعة قبل أن تؤثر على عدد كبير من المستخدمين.\n\n### 8. الفحوصات الصحية (Health Checks)\n\nالفحوصات الصحية هي نقاط نهاية (endpoints) خاصة في التطبيق تقوم بإرجاع حالته (على سبيل المثال، \"صحي\" أو \"غير صحي\"). تستخدم أنظمة الموازنة (Load Balancers) ومنصات تنسيق الحاويات (مثل Kubernetes) هذه الفحوصات لتحديد ما إذا كان يجب توجيه حركة المرور إلى نسخة معينة من التطبيق أم لا.\n\n### 9. النشر بدون توقف (Zero Downtime Deployment)\n\nالنشر بدون توقف هو استراتيجية لنشر إصدار جديد من التطبيق دون التسبب في أي انقطاع في الخدمة للمستخدمين. هناك عدة تقنيات لتحقيق ذلك، مثل النشر الأزرق والأخضر (Blue-Green Deployment) والنشر التدريجي (Canary Deployment).\n\n### 10. سير عمل Git (Git Workflow)\n\nسير عمل Git هو وصفة أو توصية لكيفية استخدام Git للعمل بطريقة متسقة ومنتجة. يحدد سير العمل الجيد كيفية إنشاء الفروع، ومتى يتم دمجها، وكيفية إدارة الإصدارات المختلفة من الكود. من أشهر نماذج سير العمل **GitFlow** و **GitHub Flow**.",
        "best_practices": "## أفضل الممارسات\n\nلتحقيق أقصى استفادة من DevOps، من المهم اتباع أفضل الممارسات والمعايير العالمية التي أثبتت فعاليتها. \n\n### 1. أفضل ممارسات خط أنابيب CI/CD\n\n*   **الالتزام المتكرر والمبكر (Commit Early, Commit Often):** قم بدمج تغييرات صغيرة ومتكررة في المستودع الرئيسي. هذا يسهل اكتشاف الأخطاء ويقلل من تعقيد حل النزاعات.\n*   **بناء مرة واحدة (Build Once):** يجب بناء الكود المصدري مرة واحدة فقط وإنشاء \"قطعة أثرية\" (artifact) يتم استخدامها في جميع المراحل اللاحقة (الاختبار، النشر). هذا يضمن أن ما يتم اختباره هو نفسه ما يتم نشره.\n*   **اجعل البناء سريعًا:** يجب أن تكون عملية البناء سريعة قدر الإمكان لتوفير تغذية راجعة سريعة للمطورين. الهدف المثالي هو \"بناء العشر دقائق\" (Ten-Minute Build).\n*   **أتمتة الاختبارات:** قم بأتمتة جميع أنواع الاختبارات (الوحدة، التكامل، الواجهة الأمامية) ودمجها في خط الأنابيب. هذا يضمن جودة الكود ويقلل من الأخطاء البشرية.\n*   **الأمان أولاً (Shift Left Security):** قم بدمج فحوصات الأمان في وقت مبكر من خط الأنابيب (مثل فحص الثغرات في المكتبات، تحليل الكود الثابت). هذا يقلل من تكلفة إصلاح الثغرات الأمنية.\n\n### 2. أفضل ممارسات Docker\n\n*   **استخدام صور أساسية صغيرة (Use Small Base Images):** ابدأ بصور أساسية صغيرة (مثل `alpine`) لتقليل حجم الصورة النهائية. الصور الأصغر أسرع في النقل وأقل عرضة للثغرات الأمنية.\n*   **استخدام البناء متعدد المراحل (Multi-stage Builds):** استخدم البناء متعدد المراحل لفصل بيئة البناء عن بيئة التشغيل. هذا يسمح لك بتضمين الأدوات والمكتبات اللازمة للبناء فقط في مرحلة البناء، بينما تحتوي الصورة النهائية على التطبيق وتبعياته الأساسية فقط.\n*   **تقليل عدد الطبقات (Minimize Layers):** كل تعليمة في `Dockerfile` تنشئ طبقة جديدة. قم بدمج الأوامر ذات الصلة معًا باستخدام `&&` لتقليل عدد الطبقات وحجم الصورة.\n*   **تشغيل كعملية واحدة لكل حاوية (One Process Per Container):** من الأفضل تشغيل عملية واحدة فقط في كل حاوية. هذا يسهل إدارة الحاويات ومراقبتها وتوسيعها.\n*   **لا تقم بتشغيل الحاويات كـ `root`:** قم بإنشاء مستخدم غير جذري (non-root user) وتشغيل التطبيق باستخدامه لتقليل المخاطر الأمنية.\n\n### 3. أفضل ممارسات إدارة متغيرات البيئة\n\n*   **فصل التكوين عن الكود:** لا تقم أبدًا بتضمين القيم الحساسة (مثل كلمات المرور ومفاتيح API) مباشرة في الكود. استخدم متغيرات البيئة لتمرير هذه القيم إلى التطبيق.\n*   **استخدام ملفات `.env` للتطوير المحلي:** استخدم ملفات `.env` لتخزين متغيرات البيئة في بيئة التطوير المحلية. تأكد من إضافة `.env` إلى ملف `.gitignore` لمنع تسريبها إلى مستودع الكود.\n*   **استخدام أدوات إدارة الأسرار في الإنتاج:** في بيئات الإنتاج، استخدم أدوات متخصصة لإدارة الأسرار مثل AWS Secrets Manager, Azure Key Vault, or HashiCorp Vault. هذه الأدوات توفر تشفيرًا قويًا وتحكمًا في الوصول وتدويرًا للأسرار.\n*   **التحقق من صحة متغيرات البيئة عند بدء التشغيل:** قم بالتحقق من وجود جميع متغيرات البيئة المطلوبة وصحتها عند بدء تشغيل التطبيق. هذا يمنع حدوث أخطاء غير متوقعة أثناء التشغيل.\n\n### 4. أفضل ممارسات التسجيل (Logging)\n\n*   **استخدام التسجيل المنظم (Structured Logging):** قم بتسجيل الرسائل بتنسيق منظم مثل JSON. هذا يسهل على الأنظمة الآلية تحليل السجلات والبحث فيها وتصفيتها.\n*   **لا تسجل معلومات حساسة:** تجنب تسجيل أي معلومات حساسة مثل كلمات المرور أو أرقام بطاقات الائتمان أو البيانات الشخصية.\n*   **استخدام مستويات السجل (Log Levels):** استخدم مستويات السجل المختلفة (مثل DEBUG, INFO, WARN, ERROR, FATAL) بشكل صحيح. هذا يسمح لك بتصفية السجلات بناءً على أهميتها.\n*   **إضافة سياق إلى السجلات:** قم بتضمين معلومات سياقية مفيدة في كل رسالة سجل، مثل معرف الطلب (request ID) ومعرف المستخدم (user ID). هذا يساعد في تتبع الطلبات وتصحيح الأخطاء.\n\n### 5. أفضل ممارسات مراقبة الأخطاء (Sentry)\n\n*   **تكوين خرائط المصدر (Source Maps):** قم بتكوين خرائط المصدر لتطبيقات الواجهة الأمامية (JavaScript). هذا يسمح لـ Sentry بعرض تتبعات المكدس (stack traces) المقروءة بدلاً من الكود المصغر.\n*   **إثراء بيانات الخطأ:** أضف سياقًا إضافيًا إلى تقارير الأخطاء، مثل معلومات المستخدم الحالي وإصدار التطبيق. هذا يساعد في فهم سبب الخطأ وتأثيره.\n*   **تكامل مع أدوات أخرى:** قم بدمج Sentry مع أدوات أخرى مثل Slack و Jira لإنشاء تنبيهات وتذاكر تلقائية عند حدوث أخطاء جديدة.\n\n### 6. أفضل ممارسات الفحوصات الصحية\n\n*   **توفير نقطة نهاية للفحص الصحي:** قم بإنشاء نقطة نهاية HTTP (مثل `/health`) في تطبيقك تقوم بإرجاع رمز الحالة `200 OK` إذا كان التطبيق يعمل بشكل صحيح.\n*   **التمييز بين فحوصات الحياة (Liveness) والجاهزية (Readiness):** \n    *   **فحص الحياة:** يتحقق مما إذا كان التطبيق يعمل أم لا. إذا فشل هذا الفحص، يجب إعادة تشغيل الحاوية.\n    *   **فحص الجاهزية:** يتحقق مما إذا كان التطبيق جاهزًا لاستقبال حركة المرور. إذا فشل هذا الفحص، يجب إزالة الحاوية من موازن التحميل مؤقتًا.\n\n### 7. أفضل ممارسات النشر بدون توقف\n\n*   **النشر الأزرق والأخضر (Blue-Green Deployment):** قم بتشغيل نسختين متطابقتين من بيئة الإنتاج (\"الأزرق\" و \"الأخضر\"). قم بنشر الإصدار الجديد في البيئة غير النشطة (\"الأخضر\")، واختبره، ثم قم بتبديل حركة المرور إليه. هذا يسمح بالعودة السريعة إلى الإصدار القديم في حالة حدوث مشاكل.\n*   **النشر التدريجي (Canary Deployment):** قم بنشر الإصدار الجديد لمجموعة صغيرة من المستخدمين (\"الكناري\") وراقب سلوكهم وأداء التطبيق. إذا كان كل شيء على ما يرام، قم بزيادة نسبة المستخدمين الذين يتلقون الإصدار الجديد تدريجيًا.\n\n### 8. أفضل ممارسات سير عمل Git\n\n*   **استخدام فروع الميزات (Feature Branches):** قم بإنشاء فرع جديد لكل ميزة أو إصلاح خطأ. هذا يعزل التغييرات ويجعل مراجعة الكود أسهل.\n*   **استخدام طلبات السحب (Pull Requests):** استخدم طلبات السحب لدمج فروع الميزات في الفرع الرئيسي. هذا يوفر فرصة لمراجعة الكود ومناقشته قبل الدمج.\n*   **الحفاظ على تاريخ `commit` نظيف:** اكتب رسائل `commit` واضحة وذات مغزى. استخدم `git rebase` لتنظيم سجل `commit` قبل دمج فرع الميزة.",
        "tools_technologies": "## الأدوات والتقنيات\n\nتعتمد ممارسات DevOps على مجموعة واسعة من الأدوات والتقنيات التي تساعد في أتمتة وتبسيط عمليات تطوير ونشر البرمجيات. فيما يلي قائمة بأبرز الأدوات المستخدمة في كل مجال:\n\n### 1. أدوات CI/CD\n\n*   **Jenkins:** خادم أتمتة مفتوح المصدر وقابل للتوسيع بشكل كبير. يعتبر من أقدم وأشهر أدوات CI/CD ويتميز بمجتمع كبير ومجموعة ضخمة من الإضافات (plugins).\n*   **GitLab CI/CD:** ميزة مدمجة في منصة GitLab توفر إمكانات CI/CD قوية. يتم تعريف خطوط الأنابيب في ملف `gitlab-ci.yml.`.\n*   **GitHub Actions:** منصة أتمتة مدمجة في GitHub تسمح ببناء واختبار ونشر الكود مباشرة من المستودع. يتم تعريف سير العمل في ملفات YAML.\n*   **CircleCI:** منصة CI/CD سحابية تتميز بالسرعة وسهولة الإعداد. تدعم Docker بشكل ممتاز وتوفر تكاملًا مع العديد من الخدمات الأخرى.\n\n### 2. أدوات الحاويات والتنسيق (Containerization & Orchestration)\n\n*   **Docker:** المنصة الرائدة لإنشاء وتشغيل الحاويات. تسمح بتغليف التطبيقات وتبعياتها في بيئات معزولة ومحمولة.\n*   **Kubernetes (K8s):** نظام تنسيق حاويات مفتوح المصدر وقوي للغاية. يقوم بأتمتة نشر وتوسيع وإدارة التطبيقات المعبأة في حاويات.\n*   **Docker Swarm:** حل تنسيق الحاويات الأصلي من Docker. يعتبر أبسط من Kubernetes ولكنه أقل قوة ومرونة.\n\n### 3. أدوات إدارة الأسرار ومتغيرات البيئة\n\n*   **HashiCorp Vault:** أداة متخصصة لإدارة الأسرار بشكل آمن. توفر تخزينًا مركزيًا وتشفيرًا وتحكمًا دقيقًا في الوصول إلى الأسرار.\n*   **AWS Secrets Manager:** خدمة مُدارة من Amazon Web Services لتخزين وإدارة وتدوير الأسرار.\n*   **Azure Key Vault:** خدمة سحابية من Microsoft Azure لتخزين وإدارة المفاتيح والأسرار والشهادات.\n*   **Doppler:** منصة لإدارة متغيرات البيئة والأسرار عبر جميع البيئات والمشاريع.\n\n### 4. أدوات التسجيل (Logging)\n\n*   **ELK Stack (Elasticsearch, Logstash, Kibana):** مجموعة شائعة من الأدوات المفتوحة المصدر لجمع ومعالجة وتخزين وتحليل وتصور السجلات.\n*   **Splunk:** منصة قوية لتحليل البيانات التشغيلية، بما في ذلك السجلات والمقاييس.\n*   **Graylog:** منصة إدارة سجلات مفتوحة المصدر توفر جمعًا وتحليلاً مركزيًا للسجلات.\n*   **Fluentd:** جامع بيانات مفتوح المصدر يسمح بجمع ومعالجة السجلات من مصادر مختلفة وإرسالها إلى وجهات متعددة.\n\n### 5. أدوات مراقبة الأخطاء\n\n*   **Sentry:** منصة مراقبة أخطاء مفتوحة المصدر وشائعة تساعد المطورين على اكتشاف وتشخيص وإصلاح الأخطاء في الوقت الفعلي.\n*   **Bugsnag:** أداة لمراقبة استقرار التطبيقات والإبلاغ عن الأخطاء مع بيانات تشخيصية غنية.\n*   **Rollbar:** خدمة لمراقبة الأخطاء وتصحيحها في الوقت الفعلي، تدعم مجموعة واسعة من لغات البرمجة والأطر.\n\n### 6. أدوات النشر بدون توقف\n\n*   **Nginx / HAProxy:** خوادم وكيل عكسي (reverse proxy) وموازنات تحميل (load balancers) قوية يمكن استخدامها لتوجيه حركة المرور بين الإصدارات المختلفة من التطبيق أثناء عمليات النشر.\n*   **موازنات التحميل السحابية (Cloud Load Balancers):** توفر خدمات مثل AWS Elastic Load Balancing و Azure Load Balancer و Google Cloud Load Balancing ميزات مدمجة لدعم استراتيجيات النشر بدون توقف.\n\n### 7. أدوات سير عمل Git\n\n*   **Git:** نظام التحكم في الإصدارات الموزع الذي يشكل أساس DevOps الحديث.\n*   **GitHub / GitLab / Bitbucket:** منصات استضافة Git قائمة على الويب توفر ميزات إضافية مثل مراجعة الكود (طلبات السحب) وتتبع المشكلات و CI/CD المتكامل.",
        "code_examples": "## أمثلة الكود\n\nتوفر أمثلة الكود التالية رؤى عملية حول كيفية تطبيق المفاهيم التي تمت مناقشتها.\n\n### 1. مثال على ملف `.gitlab-ci.yml` لخط أنابيب CI/CD\n\nهذا المثال يوضح خط أنابيب بسيط لتطبيق Node.js باستخدام GitLab CI/CD. يتضمن مراحل لتثبيت التبعيات، تشغيل الاختبارات، وبناء صورة Docker.\n\n```yaml\n# .gitlab-ci.yml\n\nimage: node:18-alpine\n\nstages:\n  - install\n  - test\n  - build\n\ncache:\n  paths:\n    - node_modules/\n\ninstall_dependencies:\n  stage: install\n  script:\n    - npm install\n\ntest_app:\n  stage: test\n  script:\n    - npm test\n\nbuild_docker_image:\n  stage: build\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  script:\n    - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  only:\n    - main\n```\n\n**شرح:**\n\n*   `image: node:18-alpine`: يحدد صورة Docker الافتراضية التي سيتم استخدامها في جميع المهام.\n*   `stages`: يحدد المراحل المختلفة لخط الأنابيب.\n*   `cache`: يقوم بتخزين `node_modules` مؤقتًا لتسريع عمليات البناء اللاحقة.\n*   `install_dependencies`: مهمة تقوم بتثبيت تبعيات المشروع.\n*   `test_app`: مهمة تقوم بتشغيل الاختبارات الآلية.\n*   `build_docker_image`: مهمة تقوم ببناء ونشر صورة Docker إلى سجل GitLab. يتم تشغيل هذه المهمة فقط عند الدمج في الفرع `main`.\n\n### 2. مثال على `Dockerfile` باستخدام البناء متعدد المراحل\n\nهذا المثال يوضح كيفية إنشاء صورة Docker محسّنة لتطبيق React باستخدام البناء متعدد المراحل.\n\n```dockerfile\n# Dockerfile\n\n# --- المرحلة الأولى: البناء ---\nFROM node:18-alpine AS build\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\nRUN npm install\n\nCOPY . .\nRUN npm run build\n\n# --- المرحلة الثانية: الإنتاج ---\nFROM nginx:1.23-alpine\n\n# نسخ الملفات المبنية من مرحلة البناء\nCOPY --from=build /app/build /usr/share/nginx/html\n\n# نسخ تكوين Nginx المخصص (اختياري)\n# COPY nginx.conf /etc/nginx/conf.d/default.conf\n\nEXPOSE 80\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n**شرح:**\n\n*   **المرحلة الأولى (`build`):** تستخدم صورة `node:18-alpine` الكاملة التي تحتوي على جميع الأدوات اللازمة لبناء تطبيق React. يتم نسخ الكود، تثبيت التبعيات، وتشغيل أمر البناء. والنتيجة هي مجلد `build` يحتوي على الملفات الثابتة للتطبيق.\n*   **المرحلة الثانية (`production`):** تبدأ من صورة `nginx:1.23-alpine` صغيرة جدًا. يتم نسخ مجلد `build` فقط من المرحلة الأولى إلى هذه المرحلة. الصورة النهائية تحتوي فقط على خادم Nginx والملفات الثابتة للتطبيق، مما يجعلها صغيرة وآمنة.\n\n### 3. مثال على ملف `docker-compose.yml`\n\nهذا المثال يوضح كيفية استخدام Docker Compose لتشغيل تطبيق ويب متعدد الحاويات يتكون من خدمة ويب وقاعدة بيانات.\n\n```yaml\n# docker-compose.yml\n\nversion: '3.8'\n\nservices:\n  webapp:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DB_HOST=database\n      - DB_USER=user\n      - DB_PASSWORD=secret\n      - DB_NAME=mydb\n    depends_on:\n      - database\n\n  database:\n    image: postgres:14-alpine\n    volumes:\n      - db_data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=secret\n      - POSTGRES_DB=mydb\n\nvolumes:\n  db_data:\n```\n\n**شرح:**\n\n*   `services`: يحدد الخدمات (الحاويات) التي يتكون منها التطبيق.\n*   `webapp`: خدمة تطبيق الويب. يتم بناؤها من `Dockerfile` في الدليل الحالي. يتم تعيين متغيرات البيئة لتكوين اتصال قاعدة البيانات.\n*   `database`: خدمة قاعدة البيانات التي تستخدم صورة PostgreSQL. يتم استخدام `volume` (`db_data`) للحفاظ على بيانات قاعدة البيانات حتى بعد إيقاف الحاوية.\n*   `depends_on`: يضمن أن خدمة `database` ستبدأ قبل خدمة `webapp`.",
        "practical_tips": "## نصائح عملية\n\nلتطبيق ممارسات DevOps بفعالية، إليك بعض النصائح العملية التي يمكنك البدء بها فورًا:\n\n1.  **ابدأ صغيرًا:** لا تحاول تطبيق كل شيء دفعة واحدة. ابدأ بمشروع واحد وأتمتة جزء صغير من العملية، مثل التكامل المستمر. ثم قم بالتوسع تدريجيًا.\n\n2.  **عزز ثقافة التعاون:** شجع التواصل المفتوح والتعاون بين فرق التطوير والعمليات. عقد اجتماعات منتظمة ومشاركة المسؤوليات يمكن أن يساعد في كسر الحواجز.\n\n3.  **استثمر في الأدوات المناسبة:** اختر الأدوات التي تناسب احتياجات فريقك وميزانيتك. الأدوات المفتوحة المصدر مثل Jenkins و GitLab CI/CD هي نقاط انطلاق ممتازة.\n\n4.  **اجعل كل شيء كود (Everything as Code):** لا تقتصر على \"البنية التحتية كود\" (Infrastructure as Code). قم بتطبيق نفس المبدأ على خطوط الأنابيب (Pipelines as Code) والتكوين (Configuration as Code).\n\n5.  **راقب كل شيء:** قم بإعداد لوحات معلومات (dashboards) لمراقبة أداء خطوط الأنابيب، وصحة التطبيقات، واستخدام الموارد. استخدم هذه البيانات لتحديد نقاط الضعف وتحسين العمليات.\n\n6.  **لا تخف من الفشل:** الفشل جزء من عملية التعلم. عندما يفشل بناء أو نشر، قم بتحليل السبب الجذري للمشكلة واتخذ خطوات لمنع تكرارها في المستقبل.\n\n7.  **ركز على الأمان منذ البداية:** لا تترك الأمان لمرحلة متأخرة. قم بدمج ممارسات الأمان في كل مرحلة من مراحل دورة حياة تطوير البرمجيات (DevSecOps).\n\n8.  **قم بتوثيق عملياتك:** قم بتوثيق كيفية عمل خطوط الأنابيب الخاصة بك، وكيفية تكوين البيئات، وماذا تفعل في حالة حدوث خطأ. هذا يساعد في تأهيل أعضاء الفريق الجدد ويضمن الاتساق.\n",
        "common_mistakes": "## الأخطاء الشائعة وكيفية تجنبها\n\nعند تبني ممارسات DevOps، تقع العديد من الفرق في أخطاء شائعة يمكن أن تعرقل تقدمها. فيما يلي بعض هذه الأخطاء وكيفية تجنبها:\n\n1.  **التركيز على الأدوات بدلاً من الثقافة:**\n    *   **الخطأ:** الاعتقاد بأن شراء أدوات DevOps جديدة سيحل جميع المشاكل. DevOps هو في الأساس تحول ثقافي يتعلق بالتعاون والتواصل والمسؤولية المشتركة.\n    *   **الحل:** ركز على بناء ثقافة التعاون أولاً. شجع فرق التطوير والعمليات على العمل معًا، ثم اختر الأدوات التي تدعم هذه الثقافة.\n\n2.  **عدم وجود دعم من الإدارة العليا:**\n    *   **الخطأ:** محاولة تطبيق DevOps دون الحصول على موافقة ودعم من الإدارة. يتطلب تحول DevOps استثمارًا في الوقت والموارد، وبدون دعم إداري، من المرجح أن يفشل.\n    *   **الحل:** قم بتوضيح فوائد DevOps للإدارة من حيث سرعة التسليم وجودة المنتج وتقليل التكاليف. ابدأ بمشروع تجريبي لإثبات القيمة.\n\n3.  **إهمال الاختبارات الآلية:**\n    *   **الخطأ:** إنشاء خط أنابيب CI/CD يقوم بالبناء والنشر تلقائيًا ولكن مع تغطية اختبار غير كافية. هذا يؤدي إلى نشر الأخطاء بسرعة إلى بيئة الإنتاج.\n    *   **الحل:** استثمر في كتابة مجموعة شاملة من الاختبارات الآلية (الوحدة، التكامل، وغيرها). اجعل اجتياز جميع الاختبارات شرطًا أساسيًا للانتقال إلى المرحلة التالية في خط الأنابيب.\n\n4.  **بيئات غير متطابقة:**\n    *   **الخطأ:** وجود اختلافات كبيرة بين بيئات التطوير والاختبار والإنتاج. هذا يؤدي إلى ظهور أخطاء في الإنتاج لم تظهر في البيئات السابقة (\"لكنها تعمل على جهازي!\").\n    *   **الحل:** استخدم تقنيات مثل Docker و \"البنية التحتية كود\" لضمان أن جميع البيئات متطابقة قدر الإمكان.\n\n5.  **تجاهل الأمان (DevSecOps):**\n    *   **الخطأ:** التعامل مع الأمان كخطوة أخيرة في العملية، أو كمسؤولية فريق الأمان فقط. هذا يجعل إصلاح الثغرات الأمنية مكلفًا وبطيئًا.\n    *   **الحل:** قم بدمج الأمان في كل مرحلة من مراحل دورة حياة التطوير. استخدم أدوات لفحص الكود والمكتبات بحثًا عن الثغرات الأمنية تلقائيًا داخل خط أنابيب CI/CD.\n\n6.  **القياسات غير الفعالة (Vanity Metrics):**\n    *   **الخطأ:** التركيز على قياسات لا تعكس القيمة الحقيقية للأعمال، مثل عدد عمليات النشر في اليوم، دون النظر إلى تأثير هذه العمليات.\n    *   **الحل:** ركز على القياسات التي تهم الأعمال، مثل متوسط الوقت اللازم للإصلاح (MTTR)، ومعدل فشل التغيير، ورضا العملاء.",
        "checklist": "## قائمة التحقق\n\nاستخدم قائمة التحقق هذه لتقييم مدى نضج ممارسات DevOps والنشر في فريقك وتحديد مجالات التحسين.\n\n### CI/CD\n\n- [ ] هل يتم دمج الكود في الفرع الرئيسي مرة واحدة على الأقل يوميًا؟\n- [ ] هل يتم تشغيل بناء واختبارات آلية بعد كل عملية دمج؟\n- [ ] هل عملية البناء تستغرق أقل من 10 دقائق؟\n- [ ] هل يتم بناء \"القطعة الأثرية\" (artifact) مرة واحدة فقط؟\n- [ ] هل يتم نشر التغييرات في بيئة ما قبل الإنتاج (staging) تلقائيًا؟\n- [ ] هل يتم تضمين فحوصات الأمان (SAST/DAST) في خط الأنابيب؟\n\n### Docker والحاويات\n\n- [ ] هل يتم استخدام صور أساسية صغيرة وموثوقة؟\n- [ ] هل يتم استخدام البناء متعدد المراحل لتقليل حجم الصور؟\n- [ ] هل يتم تشغيل الحاويات باستخدام مستخدم غير جذري (non-root)؟\n- [ ] هل يتم تجنب تضمين الأسرار مباشرة في الصور؟\n\n### إدارة التكوين والأسرار\n\n- [ ] هل يتم فصل التكوين عن الكود؟\n- [ ] هل يتم استخدام أداة متخصصة لإدارة الأسرار في بيئة الإنتاج؟\n- [ ] هل يتم تجنب تخزين ملفات `.env` التي تحتوي على أسرار في مستودع Git؟\n\n### التسجيل والمراقبة\n\n- [ ] هل يتم استخدام التسجيل المنظم (structured logging)؟\n- [ ] هل يتم تجنب تسجيل المعلومات الحساسة؟\n- [ ] هل يتم تجميع السجلات في مكان مركزي لتحليلها؟\n- [ ] هل هناك أداة لمراقبة الأخطاء في الوقت الفعلي (مثل Sentry)؟\n- [ ] هل تم تكوين تنبيهات للأخطاء الحرجة؟\n\n### النشر والصحة\n\n- [ ] هل يتم استخدام استراتيجية نشر بدون توقف (مثل Blue-Green أو Canary)؟\n- [ ] هل يوفر التطبيق نقطة نهاية للفحص الصحي (health check)؟\n- [ ] هل يتم التمييز بين فحوصات الحياة (liveness) والجاهزية (readiness)؟\n\n### سير عمل Git\n\n- [ ] هل يتم استخدام فروع الميزات (feature branches) لتطوير الميزات الجديدة؟\n- [ ] هل يتم استخدام طلبات السحب (pull requests) لمراجعة الكود؟\n- [ ] هل رسائل `commit` واضحة وتصف التغييرات بشكل جيد؟",
        "sources": "## المصادر\n\n1.  [11 DevOps Best Practices Developers Should Use | Salesforce](https://www.salesforce.com/platform/devops-tools/what-is-devops/devops-best-practices/)\n2.  [Continuous integration best practices | GitLab](https://about.gitlab.com/topics/ci-cd/continuous-integration-best-practices/)\n3.  [Building best practices | Docker Documentation](https://docs.docker.com/build/building/best-practices/)\n4.  [Environment Variables: How to Use Them and 4 Critical Best Practices | Configu](https://configu.com/blog/environment-variables-how-to-use-them-and-4-critical-best-practices/)\n5.  [Logging Best Practices: 12 Dos and Don'ts | Betterstack](https://betterstack.com/community/guides/logging/logging-best-practices/)\n6.  [An Engineer's Checklist of Logging Best Practices | Honeycomb](https://www.honeycomb.io/blog/engineers-checklist-logging-best-practices)\n7.  [Safe deployment practices - Azure DevOps | Microsoft Learn](https://learn.microsoft.com/en-us/devops/operate/safe-deployment-practices)\n8.  [What Is Structured Logging and Why Developers Need It | Stackify](https://stackify.com/what-is-structured-logging-and-why-developers-need-it/)\n9.  [Top 20 Dockerfile best practices | Sysdig](https://sysdig.com/learn-cloud-native/dockerfile-best-practices)\n10. [The DevOps Handbook](https://itrevolution.com/product/the-devops-handbook-second-edition/)"
      },
      "error": ""
    },
    {
      "input": "هيكلة المشروع والتوثيق: Project Structure Best Practices, Folder Organization, Monorepo vs Multi-repo, README Documentation, API Documentation, Code Comments, Changelog, Semantic Versioning",
      "output": {
        "topic_title": "هيكلة المشروع والتوثيق: أفضل الممارسات والمعايير",
        "introduction": "تُعد هيكلة المشروع والتوثيق الجيد من الركائز الأساسية لنجاح أي مشروع برمجي، سواء كان صغيرًا أو كبيرًا. فهي لا تقتصر على تنظيم الملفات والمجلدات، بل تمتد لتشمل كيفية كتابة الكود، وتوثيقه، وإدارة التغييرات، والتواصل بين أعضاء الفريق. إن وجود هيكل واضح وتوثيق شامل يسهل على المطورين فهم المشروع، وصيانته، وتطويره بكفاءة، كما يقلل من الأخطاء ويسرع من وتيرة العمل. في هذا التقرير، سنستعرض بالتفصيل أفضل الممارسات والمعايير العالمية المتعلقة بهيكلة المشاريع والتوثيق، بدءًا من تنظيم المجلدات واختيار بين نهجي Monorepo و Multi-repo، وصولًا إلى كتابة توثيق احترافي للمشروع وواجهاته البرمجية (APIs).",
        "key_concepts": "لفهم أعمق للموضوع، لا بد من توضيح بعض المفاهيم والمصطلحات الأساسية التي تشكل حجر الزاوية في هيكلة المشاريع وتوثيقها:\n\n*   **هيكلة المشروع (Project Structure):** هي الطريقة التي يتم بها تنظيم وترتيب الملفات والمجلدات والمكونات المختلفة داخل المشروع البرمجي. تهدف الهيكلة الجيدة إلى جعل المشروع سهل الفهم، الصيانة، والتوسيع.\n\n*   **تنظيم المجلدات (Folder Organization):** جزء أساسي من هيكلة المشروع، حيث يتم تجميع الملفات ذات الصلة في مجلدات منطقية. على سبيل المثال، فصل ملفات الواجهة الأمامية عن الخلفية، أو تجميع كل ما يتعلق بميزة معينة في مجلد واحد.\n\n*   **Monorepo (المستودع الأحادي):** استراتيجية لإدارة الإصدارات حيث يتم تخزين الكود المصدري لعدة مشاريع أو مكتبات في مستودع واحد (Single Repository). شركات مثل Google و Facebook تستخدم هذا النهج.\n\n*   **Multi-repo (المستودعات المتعددة):** النهج الأكثر شيوعًا، حيث يكون لكل مشروع أو مكتبة مستودع خاص بها (Separate Repository). هذا يسمح باستقلالية أكبر بين المشاريع.\n\n*   **توثيق README:** هو ملف (عادةً `README.md`) يوجد في جذر المشروع، ويعتبر بمثابة نقطة البداية لأي شخص يتعامل مع المشروع. يقدم الملف نظرة عامة على المشروع، كيفية تثبيته، استخدامه، والمساهمة فيه.\n\n*   **توثيق الواجهات البرمجية (API Documentation):** دليل شامل يشرح كيفية استخدام والتكامل مع واجهة برمجية (API). يتضمن تفاصيل حول نقاط النهاية (Endpoints)، طرق الطلب (Methods)، المعلمات (Parameters)، المصادقة (Authentication)، والأمثلة العملية.\n\n*   **تعليقات الكود (Code Comments):** شروحات مكتوبة داخل الكود المصدري نفسه لتوضيح وظيفة جزء معين من الكود، أو منطق معقد، أو سبب اتخاذ قرار برمجي معين. هدفها جعل الكود أكثر قابلية للقراءة والفهم.\n\n*   **سجل التغييرات (Changelog):** ملف (عادةً `CHANGELOG.md`) يسجل جميع التغييرات المهمة التي تحدث في المشروع مع كل إصدار جديد، مثل الميزات الجديدة، إصلاحات الأخطاء، والتغييرات التي قد تؤثر على التوافقية.\n\n*   **الإصدار الدلالي (Semantic Versioning):** هو معيار بسيط لترقيم إصدارات البرمجيات. يتكون رقم الإصدار من ثلاثة أجزاء: `MAJOR.MINOR.PATCH` (رئيسي.فرعي.تصحيح). يتم زيادة الرقم `MAJOR` عند إجراء تغييرات غير متوافقة مع الإصدارات السابقة، و `MINOR` عند إضافة وظائف جديدة مع الحفاظ على التوافقية، و `PATCH` عند إجراء إصلاحات للأخطاء مع الحفاظ على التوافقية.",
        "best_practices": "لتحقيق هيكلة وتوثيق احترافي، يجب اتباع مجموعة من الممارسات المجربة والمعتمدة عالميًا. نستعرض هنا أفضل هذه الممارسات لكل جانب من جوانب الموضوع.\n\n**1. هيكلة المشروع وتنظيم المجلدات**\n\nالهيكل المنطقي للمشروع هو أساس قابليته للصيانة والتوسع. [2] يمكن تنظيم الملفات بناءً على نوعها أو وظيفتها (الفصل حسب الوظيفة)، وهو نهج بسيط ومناسب للمشاريع الصغيرة. أما في المشاريع الكبيرة، فيفضل تجميع كل الملفات المتعلقة بميزة معينة (مثل `authentication` أو `products`) في مجلد واحد (الفصل حسب الميزة)، مما يعزز النمطية (Modularity). كما يمكن الجمع بين النهجين في هيكل هجين. من الضروري أن يحتوي مجلد المصدر `src` على كل الكود المصدري للتطبيق، معزولاً عن ملفات الإعدادات والتوثيق. ويستخدم مجلد `assets` أو `public` لتخزين الملفات الثابتة مثل الصور وملفات CSS، بينما يخصص مجلد `components` أو `ui` للمكونات القابلة لإعادة الاستخدام.\n\n**2. Monorepo مقابل Multi-repo**\n\nالاختيار بين هذين النهجين يعتمد بشكل كبير على حجم الفريق، طبيعة المشاريع، ودرجة الترابط بينها. [3] يوفر الـ Monorepo رؤية شاملة للكود وإدارة مركزية للاعتماديات، مما يسهل إعادة الهيكلة الواسعة ويعزز ثقافة التطوير الموحدة، لكنه قد يصبح بطيئًا مع نمو حجمه. في المقابل، يسمح الـ Multi-repo باستقلالية الفرق وإصدار كل مكون على حدة، لكنه يتطلب مجهودًا أكبر في تنسيق التغييرات وإدارة الاعتماديات المتعددة.\n\n**3. توثيق README**\n\nملف `README.md` هو واجهة مشروعك الأولى. [4] يجب أن يبدأ باسم المشروع ووصف واضح، مع إضافة شارات (Badges) لعرض معلومات حيوية. من الضروري تقديم تعليمات دقيقة لتثبيت المشروع واستخدامه مع أمثلة، وشرح كيفية المساهمة في المشاريع المفتوحة المصدر، بالإضافة إلى ذكر نوع الترخيص بوضوح.\n\n**4. توثيق الواجهات البرمجية (API)**\n\nالتوثيق الجيد هو مفتاح تبني المطورين لواجهتك البرمجية. [5] يجب أن يكون التوثيق شاملاً، حيث يغطي كل نقطة نهاية (Endpoint) مع توضيح الـ HTTP Method والـ URL. يجب شرح كل معلم (Parameter) بالتفصيل، وتقديم أمثلة حية للطلب والاستجابة بلغات برمجة شائعة، وتوضيح عملية المصادقة بشكل كامل. الأهم من ذلك، يجب أن يظل التوثيق محدثًا باستمرار مع أي تغيير يطرأ على الـ API.",
        "tools_technologies": "*   **أدوات بناء Monorepo:**\n    *   **Lerna:** أداة شائعة لإدارة مشاريع JavaScript متعددة الحزم (packages) في مستودع واحد. تسهل إدارة الاعتماديات المشتركة وتشغيل الأوامر عبر الحزم.\n    *   **Nx:** إطار عمل متكامل لبناء مشاريع Monorepo، يوفر أدوات ذكية للبناء، الاختبار، والتخزين المؤقت (caching) لزيادة سرعة التطوير.\n    *   **Turborepo:** نظام بناء عالي الأداء لمشاريع JavaScript/TypeScript في Monorepo، يركز على السرعة والكفاءة من خلال التخزين المؤقت الذكي.\n\n*   **أدوات توثيق API:**\n    *   **Swagger (OpenAPI):** المعيار الصناعي لوصف وتوثيق واجهات RESTful APIs. أدوات مثل Swagger UI و Swagger Editor تسمح بإنشاء توثيق تفاعلي وجميل من ملفات المواصفات (YAML أو JSON).\n    *   **Postman:** أداة قوية لاختبار وتطوير APIs، وتوفر ميزات لإنشاء توثيق تلقائي من المجموعات (Collections) التي تنشئها، مع أمثلة للطلبات والاستجابات.\n    *   **Slate:** أداة لإنشاء توثيق API جميل، نظيف، وسهل القراءة بتصميم من ثلاث لوحات (three-panel design).\n\n*   **أدوات إنشاء سجل التغييرات (Changelog):**\n    *   **Conventional Commits:** مواصفات لكتابة رسائل الـ commit بطريقة منظمة. هذه الرسائل المنظمة يمكن استخدامها لتوليد سجل التغييرات تلقائيًا.\n    *   **Standard-Version:** أداة تقوم بأتمتة إدارة الإصدارات وإنشاء سجل التغييرات بناءً على مواصفات Conventional Commits.\n\n*   **أدوات تحليل الكود (Linters & Formatters):**\n    *   **ESLint:** أداة لتحليل كود JavaScript للعثور على الأنماط الإشكالية وفرض أسلوب كتابة معين.\n    *   **Prettier:** أداة لتنسيق الكود تلقائيًا، مما يضمن اتساق أسلوب الكتابة في جميع أنحاء المشروع دون أي مجهود يدوي.",
        "code_examples": "### مثال على هيكل مجلدات لمشروع ويب (نهج هجين)\n\nهذا المثال يوضح هيكل مشروع Node.js (Express) مع واجهة أمامية (React)، معتمدًا على نهج الفصل حسب الميزة.\n\n```\n/project-root\n├── .gitignore\n├── package.json\n├── README.md\n├── /docs\n│   ├── api.md\n│   └── architecture.md\n├── /src\n│   ├── /api\n│   │   ├── /auth\n│   │   │   ├── auth.controller.js\n│   │   │   ├── auth.service.js\n│   │   │   └── auth.routes.js\n│   │   ├── /products\n│   │   │   ├── products.controller.js\n│   │   │   ├── products.service.js\n│   │   │   └── products.routes.js\n│   │   └── index.js  // (يجمع كل الـ routes)\n│   ├── /config\n│   │   ├── database.js\n│   │   └── index.js\n│   ├── /middleware\n│   │   └── isAuthenticated.js\n│   ├── /models\n│   │   ├── User.js\n│   │   └── Product.js\n│   ├── /public\n│   │   ├── /css\n│   │   ├── /images\n│   │   └── /js\n│   └── server.js // (نقطة انطلاق السيرفر)\n└── /tests\n    ├── /auth\n    │   └── auth.test.js\n    └── /products\n        └── products.test.js\n```\n\n### مثال على تعليق كود مفيد\n\nالتعليقات يجب أن تشرح \"لماذا\" وليس \"ماذا\".\n\n```javascript\n// تعليق سيء (يشرح ما يفعله الكود، وهو أمر واضح)\n// a++;\n\n// تعليق جيد (يشرح سبب الحاجة إلى الكود)\n// نحتاج إلى زيادة 'a' هنا لأن الواجهة البرمجية الخارجية تتوقع فهرسًا يبدأ من 1.\na++;\n```\n\n### مثال على جزء من توثيق API باستخدام OpenAPI (Swagger)\n\nهذا المثال بصيغة YAML يوضح كيفية توثيق نقطة نهاية (endpoint) لجلب منتج معين.\n\n```yaml\npaths:\n  /products/{productId}:\n    get:\n      summary: Get a product by ID\n      description: Retrieve details for a specific product.\n      tags:\n        - Products\n      parameters:\n        - in: path\n          name: productId\n          required: true\n          schema:\n            type: string\n          description: The ID of the product to retrieve.\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Product'\n        '404':\n          description: Product not found\n```",
        "practical_tips": "1.  **ابدأ صغيرًا ومنظمًا:** حتى في المشاريع الصغيرة، ابدأ بهيكل مجلدات منطقي. من الأسهل دائمًا البدء منظمًا بدلاً من محاولة فرض النظام لاحقًا.\n2.  **اجعل الاتساق هدفًا:** اتفق مع فريقك على معايير لتسمية الملفات، هيكل المجلدات، وأسلوب كتابة الكود، والتزموا بها. استخدم أدوات مثل ESLint و Prettier لفرض هذه المعايير تلقائيًا.\n3.  **وثّق أثناء العمل، وليس بعده:** اجعل التوثيق جزءًا لا يتجزأ من عملية التطوير. اكتب التعليقات، حدّث ملف README، ووثّق نقاط الـ API الجديدة بمجرد إنشائها.\n4.  **فكر في جمهورك:** عند كتابة التوثيق، فكر فيمن سيقرأه. هل هو مطور جديد في الفريق؟ أم مطور خارجي يستخدم واجهتك البرمجية؟ اضبط مستوى التفاصيل واللغة لتناسب الجمهور.\n5.  **استخدم القوالب:** لا تعيد اختراع العجلة. استخدم قوالب جاهزة لملفات `README.md` و `CHANGELOG.md` و `CONTRIBUTING.md` كنقطة انطلاق.\n6.  **أتمتة ما يمكن أتمتته:** استخدم أدوات لأتمتة المهام المتكررة مثل إنشاء سجل التغييرات، تنسيق الكود، وتشغيل الاختبارات. هذا يوفر الوقت ويقلل من الأخطاء البشرية.\n7.  **عامل التوثيق ككود (Docs as Code):** خزّن ملفات التوثيق (خاصة المكتوبة بـ Markdown) في نفس مستودع الكود. هذا يسهل على المطورين تحديثها مع تحديث الكود، ويسمح بمراجعتها عبر Pull Requests تمامًا مثل الكود.",
        "common_mistakes": "*   **الخطأ: الإفراط في الهندسة (Over-engineering) من البداية.**\n    *   **الحل:** ابدأ بهيكل بسيط ومناسب لحجم المشروع الحالي. يمكنك دائمًا إعادة الهيكلة (refactor) وتطوير الهيكل مع نمو المشروع.\n*   **الخطأ: إهمال ملف `README.md`.**\n    *   **الحل:** اعتبره أهم ملف في مشروعك. استثمر الوقت في كتابة ملف `README` واضح ومفيد، فهو أول ما يراه أي شخص مهتم بمشروعك.\n*   **الخطأ: التعليقات التي تشرح \"ماذا\" يفعل الكود.**\n    *   **الحل:** يجب أن يكون الكود نفسه واضحًا بما يكفي لشرح \"ماذا\" يفعل. استخدم التعليقات لشرح \"لماذا\" تم كتابة الكود بهذه الطريقة، أو لشرح المنطق المعقد.\n*   **الخطأ: التوثيق غير المحدث.**\n    *   **الحل:** اجعل تحديث التوثيق جزءًا من تعريف \"الانتهاء\" (Definition of Done) لأي مهمة. لا تدمج أي تغيير في الكود إلا إذا تم تحديث التوثيق المتعلق به.\n*   **الخطأ: عدم وجود سجل تغييرات (Changelog).**\n    *   **الحل:** استخدم أدوات مثل `standard-version` مع `Conventional Commits` لإنشاء سجل تغييرات تلقائيًا. هذا يساعد المستخدمين والمطورين على تتبع التطورات بين الإصدارات بسهولة.\n*   **الخطأ: وضع البيانات الحساسة (Secrets) في الكود أو ملفات الإعدادات.**\n    *   **الحل:** استخدم متغيرات البيئة (Environment Variables) وملف `.env` (مع إضافته إلى `.gitignore`) لتخزين البيانات الحساسة مثل مفاتيح API وكلمات مرور قاعدة البيانات.",
        "checklist": "*   [ ] هل هيكل المشروع منطقي وسهل الفهم؟\n*   [ ] هل ملف `README.md` موجود، وهل هو شامل ومحدث؟\n*   [ ] هل تم اختيار النهج المناسب (Monorepo/Multi-repo) بناءً على احتياجات المشروع؟\n*   [ ] هل توثيق الـ API واضح، كامل، ويحتوي على أمثلة؟\n*   [ ] هل التعليقات في الكود تشرح \"لماذا\" وليس \"ماذا\"؟\n*   [ ] هل يوجد سجل تغييرات (Changelog) ويتم تحديثه بانتظام؟\n*   [ ] هل يتم استخدام الإصدار الدلالي (Semantic Versioning) بشكل صحيح؟\n*   [ ] هل يتم استخدام أدوات (Linters/Formatters) لضمان اتساق الكود؟\n*   [ ] هل البيانات الحساسة معزولة عن الكود المصدري؟\n*   [ ] هل عملية التثبيت والبدء (Getting Started) موثقة بوضوح؟",
        "sources": "*   [أفضل ممارسات هيكل المشروع - LinkedIn](https://ae.linkedin.com/pulse/project-structure-best-practices-springboot-divyateja-yasoju-innyc?tl=ar)\n*   [How to Structure Files and Folder in your Project? - GeeksforGeeks](https://www.geeksforgeeks.org/javascript/file-and-folder-organization-best-practices-for-web-development/)\n*   [Monorepo vs Multi-Repo: Pros and Cons of Code Repository Strategies - Kinsta](https://kinsta.com/blog/monorepo-vs-multi-repo/)\n*   [Make a README](https://www.makeareadme.com/)\n*   [API Documentation: How to Write, Examples & Best Practices - Postman](https://www.postman.com/api-platform/api-documentation/)"
      },
      "error": ""
    }
  ]
}